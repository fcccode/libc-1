Microsoft (R) Macro Assembler Version 6.15.8803		    08/27/17 03:17:23
src\conio.asm						     Page 1 - 1


				; ------------------------------------------------------------------
				.model tiny, c							; Small memoy model
				.386								; 80386 CPU
				include libc.inc						; Include library headers
			      C include stdio.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C include string.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C include ctype.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C include conio.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C include assert.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C include stdbool.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C include signal.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C include time.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C 
 0000				.data								; Data segment
 0000 0F			 txtc  db 15							; Text color
 0001 00			 txtbg db 0							; Text background
 0002  0040 [			buffered BYTE 64 dup(?)					; Buffer for returning data
        00
       ]
 0042 30 31 32 33 34 35		 hexstr   db '0123456789ABCDEF'
       36 37 38 39 41 42
       43 44 45 46
 0052 30 30 00			outstr16   db '00', 0  ;register value string
 0000				    .code								; Start of code segment
				; ------------------------------------------------------------------

				 ColorAL MACRO
				    pusha
				   .IF !(al >= 09h && al <= 0dh)			    ; Ignore line feed and newline
					mov bl, txtbg					    ; Attribute (color)
					rol bl, 4					    ; Rotate left 4 bits
					or bl, txtc
					mov cx, 1					    ; Chars to print
					mov ah, 09h
					int	10h					    ; Video interupt

					mov bh, 0
					mov ah, 3					    ; Get cursor x and y
					int	10h					    ; Video interupt

					inc dl						    ; Increase x
					mov ah, 2					    ; Set cursor pos
					int	10h					    ; Video interupt
				    .ELSE
				         mov ah, 0eh
					 int	10h
				    .ENDIF
				     popa
				 ENDM


				; ------------------------------------------------------------------
				; int getch(void)
				; ------------------------------------------------------------------
				; Gets a character (an unsigned char) input.

 0000				getch PROC
 0000  B4 00			    mov ah, 0
 0002  CD 16			    int	    16h						    ; Keybord interupt
 0004  32 E4			    xor ah, ah						    ; Clear higher-half of ax

 0006  C3			    ret
 0007				getch ENDP


				; ------------------------------------------------------------------
				; int getche(void)
				; ------------------------------------------------------------------
				; Gets a character (an unsigned char) input and echo output.

 0007				getche PROC
 0007  B4 00			    mov ah, 0
 0009  CD 16			    int	    16h						    ; Keybord interupt
 000B  B4 0E			    mov ah, 0eh						    ; Teletype output
 000D  CD 10			    int     10h						    ; Video interupt
 000F  32 E4			    xor ah, ah						    ; Clear higher-half of ax

 0011  C3			    ret
 0012				getche ENDP


				; ------------------------------------------------------------------
				; int kbhit(void);
				; ------------------------------------------------------------------
				; Gets a character (an unsigned char) input and echo output.

 0012				kbhit PROC
 0012  B4 00			    mov ah, 0
 0014  CD 16			    int	    16h						    ; Keybord interupt
 0016  B8 0001			    mov ax, 1						    ; Return true

 0019  C3			    ret
 001A				kbhit ENDP


				; ------------------------------------------------------------------
				; int putch(int n)
				; ------------------------------------------------------------------
				; Writes a character (an unsigned char) specified
				; by the argument char to stdout.

 001A				putch PROC n:PTR BYTE
 001D  8B 46 04			    mov ax, n						    ; Move char into ax
 0020  B4 0E			    mov ah, 0eh						    ; Teletype output

				    .IF al == 0dh					    ; Newline on enter
 0026  CD 10				int	10h					    ; Video interupt
 0028  B0 0A				mov al, 0ah					    ; Line feed
 002A  CD 10				int	10h					    ; Video interupt
				    .ELSE
 002E  CD 10				int	10h					    ; Video interupt
				    .ENDIF

				    ret
 0032				putch ENDP


				; ------------------------------------------------------------------
				; int ungetch(int n)
				; ------------------------------------------------------------------
				; Pushes a character back into the keyboard buffer.

 0032				ungetch PROC uses cx n:PTR BYTE
 0036  8B 46 04			    mov ax, n						    ; Move char into ax
 0039  B4 05			    mov ah, 5						    ; Keybord buffer write
 003B  8A C8			    mov cl, al						    ; Char to write into buffer
 003D  CD 16			    int	    16h						    ; Keyboard interupt

				    ret
 0042				ungetch ENDP


				; ------------------------------------------------------------------
				; int clrscr()
				; ------------------------------------------------------------------
				; This function clears the screen.

 0042				clrscr PROC
 0042  B0 02			    mov al, 02h
 0044  B4 00			    mov ah, 00h
 0046  CD 10			    int	    10h						    ; Video interupt

 0048  C3			    ret
 0049				clrscr ENDP


				; ------------------------------------------------------------------
				; void gotoxy(int x, int y)
				; ------------------------------------------------------------------
				; This function moves the cursor to a new pos.

 0049				gotoxy PROC x:BYTE, y:BYTE
 004C  8A 56 04			    mov dl, x						    ; xpos
 004F  8A 76 06			    mov dh, y						    ; ypos
 0052  B7 00			    mov bh, 0
 0054  B4 02			    mov ah, 2
 0056  CD 10			    int	    10h						    ; Video interupt

				    ret
 005A				gotoxy ENDP


				; ------------------------------------------------------------------
				; void highvideo(void)
				; ------------------------------------------------------------------
				; This function sets high intensity bits for the current
				; foreground color.

 005A				highvideo PROC
 005A  A0 0000 R		    mov	al, txtc					    ; Get text color

				    .IF al <= 7						    ; Set to high intensity bit if less than or equal to 7
 0061  04 08				add al, 8
				    .ENDIF

 0063  A2 0000 R		    mov	txtc, al					    ; Store text color

 0066  C3			    ret
 0067				highvideo ENDP


				; ------------------------------------------------------------------
				; void lowvideo(void)
				; ------------------------------------------------------------------
				; This function sets low intensity bits for the current
				; foreground color.

 0067				lowvideo PROC
 0067  A0 0000 R		    mov	al, txtc					    ; Get text color

				    .IF al >= 7						    ; Set to low intensity bit if greater than or equal to 7
 006E  2C 08				sub al, 8
				    .ENDIF

 0070  A2 0000 R		    mov	txtc, al					    ; Store text color

 0073  C3			    ret
 0074				lowvideo ENDP


				; ------------------------------------------------------------------
				; void insline(void)
				; ------------------------------------------------------------------
				; A blank line is inserted at the current cursor position.
				; The previous line and lines below it scroll down.


 0074				insline PROC
 0074  B4 0E			    mov ah, 0eh						    ; Teletype output
 0076  B0 0D			    mov al, 0dh						    ; Carriage return
 0078  CD 10			    int	    10h						    ; Video interupt
 007A  B0 0A			    mov al, 0ah						    ; Line feed
 007C  CD 10			    int	    10h

 007E  C3			    ret
 007F				insline ENDP

				; ------------------------------------------------------------------
				; int wherex(void)
				; ------------------------------------------------------------------
				; This function returns the cursor x pos.

 007F				wherex PROC uses bx dx
 0081  B7 00			    mov bh, 0
 0083  B4 03			    mov ah, 3
 0085  CD 10			    int	    10h						    ; Video interupt

 0087  B4 00			    mov ah, 0
 0089  8A C2			    mov al, dl

				    ret
 008E				wherex ENDP


				; ------------------------------------------------------------------
				; int wherey(void)
				; ------------------------------------------------------------------
				; This function returns the cursor y pos.

 008E				wherey PROC uses bx dx
 0090  B7 00			    mov bh, 0
 0092  B4 03			    mov ah, 3
 0094  CD 10			    int	    10h						    ; Video interupt

 0096  B4 00			    mov ah, 0
 0098  8A C6			    mov al, dh

				    ret
 009D				wherey ENDP


				; ------------------------------------------------------------------
				; int cputs(const char * str)
				; ------------------------------------------------------------------
				; Returns a string to the screen.

 009D				cputs PROC uses si string:WORD
 00A1  8B 76 04			    mov si, string					    ; Point to param address

 00A4				  @@puts:
 00A4  AC			    lodsb						    ; Get character from string
 00A5  0A C0			    or al, al						    ; End of string
 00A7  74 30			    jz @@done
				    ColorAL
 00A9  60		     1	    pusha
 00B2  8A 1E 0001 R	     1		mov bl, txtbg					    ; Attribute (color)
 00B6  C0 C3 04		     1		rol bl, 4					    ; Rotate left 4 bits
 00B9  0A 1E 0000 R	     1		or bl, txtc
 00BD  B9 0001		     1		mov cx, 1					    ; Chars to print
 00C0  B4 09		     1		mov ah, 09h
 00C2  CD 10		     1		int	10h					    ; Video interupt
 00C4  B7 00		     1		mov bh, 0
 00C6  B4 03		     1		mov ah, 3					    ; Get cursor x and y
 00C8  CD 10		     1		int	10h					    ; Video interupt
 00CA  FE C2		     1		inc dl						    ; Increase x
 00CC  B4 02		     1		mov ah, 2					    ; Set cursor pos
 00CE  CD 10		     1		int	10h					    ; Video interupt
 00D2  B4 0E		     1	         mov ah, 0eh
 00D4  CD 10		     1		 int	10h
 00D6  61		     1	     popa
 00D7  EB CB			    jmp @@puts

 00D9				  @@done:
				    ret
 00DC				cputs ENDP


				 ; ------------------------------------------------------------------
				; int cputsxy(int x, int y, const char * str)
				; ------------------------------------------------------------------
				; Returns a string to the screen at the specified pos

 00DC				cputsxy PROC x:BYTE, y:BYTE, string:WORD
				    invoke gotoxy, x, y					    ; Move cursor to pos
				    invoke cputs, string				    ; Print colored text

				    ret
 00F8				cputsxy ENDP


				; ------------------------------------------------------------------
				; int cprintf(const char *format, ...)
				; ------------------------------------------------------------------
				; Sends formatted output to stdout.


 00F8				cprintf PROC uses di si ax bx cx dx format:WORD, args:VARARG
				local temp:word
 0104  BF 0004			    mov di, 4
 0107  8B 76 04			    mov si, format					    ; Point to param address
				    .REPEAT						    ; Iterate over string
 010A  AC				lodsb						    ; Get character from string
					.BREAK .IF !al					    ; Break if not al
					.IF al == '%'					    ; Format string identifyer
 0117  AC				    lodsb
 0118  56				    push si					    ; Store current string
 0119  83 C7 02				    add di, 2					    ; Add to param offset
 011C  8B 33				    mov si, [bp + di]				    ; Point to param address
					    .IF al == 's'				    ; Format string
						.REPEAT
 0122  AC					    lodsb
						    .BREAK .IF !al
						    ColorAL
 0127  60		     1	    pusha
 0130  8A 1E 0001 R	     1		mov bl, txtbg					    ; Attribute (color)
 0134  C0 C3 04		     1		rol bl, 4					    ; Rotate left 4 bits
 0137  0A 1E 0000 R	     1		or bl, txtc
 013B  B9 0001		     1		mov cx, 1					    ; Chars to print
 013E  B4 09		     1		mov ah, 09h
 0140  CD 10		     1		int	10h					    ; Video interupt
 0142  B7 00		     1		mov bh, 0
 0144  B4 03		     1		mov ah, 3					    ; Get cursor x and y
 0146  CD 10		     1		int	10h					    ; Video interupt
 0148  FE C2		     1		inc dl						    ; Increase x
 014A  B4 02		     1		mov ah, 2					    ; Set cursor pos
 014C  CD 10		     1		int	10h					    ; Video interupt
 0150  B4 0E		     1	         mov ah, 0eh
 0152  CD 10		     1		 int	10h
 0154  61		     1	     popa
						.UNTIL 0
 0157  5E					pop si
						.CONTINUE
					    .ELSEIF al == 'x'				    ; Format hex
 0162  56					push si
 0163  53					push bx
 0164  BF 0052 R				mov di, offset outstr16
 0167  8B C6					mov ax, si
 0169  BE 0042 R				mov si, offset hexstr
 016C  B9 0004					mov cx, 4
						.REPEAT
 016F  C1 C0 04					    rol ax, 4				    ; leftmost will
 0172  8B D8					    mov bx, ax				    ; become
 0174  83 E3 0F					    and bx, 0fh				    ; rightmost
 0177  8A 18					    mov bl, [si + bx]			    ; Index into hexstr
 0179  88 1D					    mov [di], bl
 017B  47					    inc di
						.UNTILCXZ
 017E  BE 0052 R				mov si, offset outstr16
 0181  5B					pop bx
						.REPEAT
 0182  AC					    lodsb
						    .BREAK .IF !al
						    ColorAL
 0187  60		     1	    pusha
 0190  8A 1E 0001 R	     1		mov bl, txtbg					    ; Attribute (color)
 0194  C0 C3 04		     1		rol bl, 4					    ; Rotate left 4 bits
 0197  0A 1E 0000 R	     1		or bl, txtc
 019B  B9 0001		     1		mov cx, 1					    ; Chars to print
 019E  B4 09		     1		mov ah, 09h
 01A0  CD 10		     1		int	10h					    ; Video interupt
 01A2  B7 00		     1		mov bh, 0
 01A4  B4 03		     1		mov ah, 3					    ; Get cursor x and y
 01A6  CD 10		     1		int	10h					    ; Video interupt
 01A8  FE C2		     1		inc dl						    ; Increase x
 01AA  B4 02		     1		mov ah, 2					    ; Set cursor pos
 01AC  CD 10		     1		int	10h					    ; Video interupt
 01B0  B4 0E		     1	         mov ah, 0eh
 01B2  CD 10		     1		 int	10h
 01B4  61		     1	     popa
						.UNTIL 0
 01B7  5E					pop si
 01B8  5E					pop si
						.CONTINUE
					    .ELSEIF al == 'c'				    ; Format char
 01C3  8B C6					mov ax,  si
						ColorAL
 01C5  60		     1	    pusha
 01CE  8A 1E 0001 R	     1		mov bl, txtbg					    ; Attribute (color)
 01D2  C0 C3 04		     1		rol bl, 4					    ; Rotate left 4 bits
 01D5  0A 1E 0000 R	     1		or bl, txtc
 01D9  B9 0001		     1		mov cx, 1					    ; Chars to print
 01DC  B4 09		     1		mov ah, 09h
 01DE  CD 10		     1		int	10h					    ; Video interupt
 01E0  B7 00		     1		mov bh, 0
 01E2  B4 03		     1		mov ah, 3					    ; Get cursor x and y
 01E4  CD 10		     1		int	10h					    ; Video interupt
 01E6  FE C2		     1		inc dl						    ; Increase x
 01E8  B4 02		     1		mov ah, 2					    ; Set cursor pos
 01EA  CD 10		     1		int	10h					    ; Video interupt
 01EE  B4 0E		     1	         mov ah, 0eh
 01F0  CD 10		     1		 int	10h
 01F2  61		     1	     popa
 01F3  5E					pop si
					    	.CONTINUE
					    .ELSEIF al == 'd'				    ; Format decimal
 01FD  8B C6				       	mov ax,  si
 01FF  B9 0000					mov cx, 0
 0202  BB 000A					mov bx, 10				    ; Set BX 10, for division and mod
						.REPEAT
 0205  BA 0000				    	    mov dx, 0
 0208  F7 F3					    div bx				    ; Remainder in DX, quotient in AX
 020A  41					    inc cx				    ; Increase pop loop counter
 020B  52					    push dx				    ; Push remainder, so as to reverse order when popping
						.UNTIL !ax
						.REPEAT
 0210  5A					    pop dx				    ; Pop off values in reverse order, and add 48 to make them digits
 0211  80 C2 30					    add dl, 48				    ; And save them in the string, increasing the pointer each time
 0214  8A C2					    mov al, dl				    ; Print out the number
						    ColorAL
 0216  60		     1	    pusha
 021F  8A 1E 0001 R	     1		mov bl, txtbg					    ; Attribute (color)
 0223  C0 C3 04		     1		rol bl, 4					    ; Rotate left 4 bits
 0226  0A 1E 0000 R	     1		or bl, txtc
 022A  B9 0001		     1		mov cx, 1					    ; Chars to print
 022D  B4 09		     1		mov ah, 09h
 022F  CD 10		     1		int	10h					    ; Video interupt
 0231  B7 00		     1		mov bh, 0
 0233  B4 03		     1		mov ah, 3					    ; Get cursor x and y
 0235  CD 10		     1		int	10h					    ; Video interupt
 0237  FE C2		     1		inc dl						    ; Increase x
 0239  B4 02		     1		mov ah, 2					    ; Set cursor pos
 023B  CD 10		     1		int	10h					    ; Video interupt
 023F  B4 0E		     1	         mov ah, 0eh
 0241  CD 10		     1		 int	10h
 0243  61		     1	     popa
						.UNTILCXZ
 0246  5E					pop si
						.CONTINUE
					    .ENDIF
					.ENDIF
					ColorAL
 0249  60		     1	    pusha
 0252  8A 1E 0001 R	     1		mov bl, txtbg					    ; Attribute (color)
 0256  C0 C3 04		     1		rol bl, 4					    ; Rotate left 4 bits
 0259  0A 1E 0000 R	     1		or bl, txtc
 025D  B9 0001		     1		mov cx, 1					    ; Chars to print
 0260  B4 09		     1		mov ah, 09h
 0262  CD 10		     1		int	10h					    ; Video interupt
 0264  B7 00		     1		mov bh, 0
 0266  B4 03		     1		mov ah, 3					    ; Get cursor x and y
 0268  CD 10		     1		int	10h					    ; Video interupt
 026A  FE C2		     1		inc dl						    ; Increase x
 026C  B4 02		     1		mov ah, 2					    ; Set cursor pos
 026E  CD 10		     1		int	10h					    ; Video interupt
 0272  B4 0E		     1	         mov ah, 0eh
 0274  CD 10		     1		 int	10h
 0276  61		     1	     popa
				    .UNTIL 0
				    ret
 0284				cprintf ENDP


				  ; ------------------------------------------------------------------
				; int cscanf(const char *format, ...);
				; ------------------------------------------------------------------
				; Reads formatted input from stdin.

 0284				cscanf PROC uses di si ax bx cx dx format:WORD, args:VARARG
 028D  8B 76 04			    mov si, format					    ; Point to param address
				    .IF BYTE PTR [si] == '%'
					.IF BYTE PTR [si + 1] == 's'
 029D  8B 7E 06				    mov di, [bp + 6]				    ; Point to param address
 02A0  32 C9				    xor cl, cl
					    .REPEAT
 02A2  B4 00					mov ah, 0
 02A4  CD 16					int	16h				    ; Wait for keypress
						.IF al == 08h				    ; Handle backspace
						    .CONTINUE .IF !cl			    ; No overwrite prompt
 02AE  4F					    dec di				    ; Move back a char
 02AF  C6 05 00					    mov BYTE PTR [di], 0		    ; Remove char
 02B2  FE C9					    dec cl				    ; Decrease char counter
 02B4  B4 0E					    mov ah, 0eh				    ; Teletype output
 02B6  B0 08					    mov al, 08h				    ; Backspace
 02B8  CD 10					    int	    10h				    ; Video interupt
 02BA  B0 20					    mov al, ' '				    ; Fill with blank char
 02BC  CD 10					    int     10h				    ; Video interupt
 02BE  B0 08					    mov al, 08h				    ; Backspace
 02C0  CD 10					    int     10h				    ; Video interupt
						    .CONTINUE
						.ELSEIF al == 0dh			    ; Handle enter
						    .BREAK
						.ELSEIF cl == 3dh			    ; Max input allowed
						    .BREAK
						.ENDIF
						ColorAL
 02D5  60		     1	    pusha
 02DE  8A 1E 0001 R	     1		mov bl, txtbg					    ; Attribute (color)
 02E2  C0 C3 04		     1		rol bl, 4					    ; Rotate left 4 bits
 02E5  0A 1E 0000 R	     1		or bl, txtc
 02E9  B9 0001		     1		mov cx, 1					    ; Chars to print
 02EC  B4 09		     1		mov ah, 09h
 02EE  CD 10		     1		int	10h					    ; Video interupt
 02F0  B7 00		     1		mov bh, 0
 02F2  B4 03		     1		mov ah, 3					    ; Get cursor x and y
 02F4  CD 10		     1		int	10h					    ; Video interupt
 02F6  FE C2		     1		inc dl						    ; Increase x
 02F8  B4 02		     1		mov ah, 2					    ; Set cursor pos
 02FA  CD 10		     1		int	10h					    ; Video interupt
 02FE  B4 0E		     1	         mov ah, 0eh
 0300  CD 10		     1		 int	10h
 0302  61		     1	     popa
 0303  AA					stosb					    ; Store string
 0304  FE C1					inc cl
					    .UNTIL 0
					.ELSEIF BYTE PTR [si + 1] == 'c'
 0310  8B 7E 06				    mov di, [bp + 6]				    ; Point to param address
 0313  B4 00				    mov ah, 0
 0315  CD 16				    int	16h					    ; Wait for keypress
 0317  B4 0E				    mov ah, 0eh					    ; Teletype output
 0319  CD 10				    int	10h					    ; Video interupt
 031B  AA				    stosb					    ; Store string
					.ELSEIF BYTE PTR [si + 1] == 'd'
					.ENDIF
				    .ENDIF

 0324  B4 0E			    mov ah, 0eh						    ; Teletype output
 0326  B0 0D			    mov al, 0dh						    ; Carriage return
 0328  CD 10			    int	    10h						    ; Video interupt
 032A  B0 0A			    mov al, 0ah						    ; Line feed
 032C  CD 10			    int	    10h						    ; Video interupt

				    ret
 0336				cscanf ENDP


				; ------------------------------------------------------------------
				; void textbackground(int color)
				; ------------------------------------------------------------------
				; Change of current background color in text mode.

 0336				textbackground PROC uses ax color:BYTE
 033A  8A 46 04			    mov al, color					    ; Move color to al
 033D  A2 0001 R		    mov	txtbg, al					    ; Set text background color to al

				    ret
 0343				textbackground ENDP


				; ------------------------------------------------------------------
				; void textcolor(int color)
				; ------------------------------------------------------------------
				; change the color of drawing text where color is a integer variable.

 0343				textcolor PROC uses ax color:BYTE
 0347  8A 46 04			    mov al, color					    ; Move color to al
 034A  A2 0000 R		    mov	txtc, al					    ; Set text color to al

				    ret
 0350				textcolor ENDP


				; ------------------------------------------------------------------
				; void cursoroff(void)
				; ------------------------------------------------------------------
				; This function turns the cursor off

 0350				cursoroff PROC uses ax cx
 0352  B5 20			    mov ch, 32
 0354  B4 01			    mov ah, 1
 0356  B0 03			    mov al, 3
 0358  CD 10			    int	    10h

				    ret
 035D				cursoroff ENDP


				; ------------------------------------------------------------------
				; void cursoron(void)
				; ------------------------------------------------------------------
				; This function turns the cursor on

 035D				cursoron PROC uses ax cx
 035F  B5 06			    mov ch, 6
 0361  B1 07			    mov cl, 7
 0363  B4 01			    mov ah, 1
 0365  B0 03			    mov al, 3
 0367  CD 10			    int	    10h

				    ret
 036C				cursoron ENDP


				; ------------------------------------------------------------------
				; void delay(int ms)
				; ------------------------------------------------------------------
				; This function delays the program

 036C				delay PROC uses ax cx dx ms:PTR BYTE
 0372  8B 4E 04			    mov cx, ms						    ; ms delay
 0375  BA 4240			    mov dx, 4240h
 0378  B4 86			    mov ah, 86h
 037A  CD 15			    int 15h

				    ret
 0381				delay ENDP


				; ------------------------------------------------------------------
				; void newline(void)
				; ------------------------------------------------------------------
				; This function writes a new line

 0381				newline PROC uses ax
 0382  B4 0E			    mov ah, 0eh						    ; Teletype output
 0384  B0 0D			    mov al, 0dh						    ; Carriage return
 0386  CD 10			    int	    10h						    ; Video interupt
 0388  B0 0A			    mov al, 0ah						    ; Line feed
 038A  CD 10			    int	    10h						    ; Video interupt

				    ret
 038E				newline ENDP


				; ------------------------------------------------------------------
				; void setcursortype(int cur)
				; ------------------------------------------------------------------
				; This function moves the cursor to a new pos

 038E				setcursortype PROC uses ax cx cur:BYTE
 0393  8A 6E 04			    mov ch, cur						; Cursor type
 0396  B1 07			    mov cl, 7
 0398  B4 01			    mov ah, 1
 039A  B0 03			    mov al, 3
 039C  CD 10			    int	    10h

				    ret
 03A2				setcursortype ENDP

				END
Microsoft (R) Macro Assembler Version 6.15.8803		    08/27/17 03:17:23
src\conio.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

ColorAL  . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

tm . . . . . . . . . . . . . . .	 0012
  tm_sec . . . . . . . . . . . .	 0000	     Word
  tm_min . . . . . . . . . . . .	 0002	     Word
  tm_hour  . . . . . . . . . . .	 0004	     Word
  tm_mday  . . . . . . . . . . .	 0006	     Word
  tm_mon . . . . . . . . . . . .	 0008	     Word
  tm_year  . . . . . . . . . . .	 000A	     Word
  tm_wday  . . . . . . . . . . .	 000C	     Word
  tm_yday  . . . . . . . . . . .	 000E	     Word
  tm_isdst . . . . . . . . . . .	 0010	     Word


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_TEXT  . . . . . . . . . . . . .	16 Bit	 03A2	  Word	  Public  'CODE'	
_DATA  . . . . . . . . . . . . .	16 Bit	 0055	  Word	  Public  'DATA'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

_assert  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
bcd  . . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
clrscr . . . . . . . . . . . . .	P Near	 0042	  _TEXT	Length= 0007 Public C
cprintf  . . . . . . . . . . . .	P Near	 00F8	  _TEXT	Length= 018C Public C
  format . . . . . . . . . . . .	Word	 bp + 0004
  args . . . . . . . . . . . . .		 bp + 0006
  temp . . . . . . . . . . . . .	Word	 bp - 0002
cputsxy  . . . . . . . . . . . .	P Near	 00DC	  _TEXT	Length= 001C Public C
  x  . . . . . . . . . . . . . .	Byte	 bp + 0004
  y  . . . . . . . . . . . . . .	Byte	 bp + 0006
  string . . . . . . . . . . . .	Word	 bp + 0008
cputs  . . . . . . . . . . . . .	P Near	 009D	  _TEXT	Length= 003F Public C
  string . . . . . . . . . . . .	Word	 bp + 0004
  @@puts . . . . . . . . . . . .	L Near	 00A4	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 00D9	  _TEXT	
cscanf . . . . . . . . . . . . .	P Near	 0284	  _TEXT	Length= 00B2 Public C
  format . . . . . . . . . . . .	Word	 bp + 0004
  args . . . . . . . . . . . . .		 bp + 0006
cursoroff  . . . . . . . . . . .	P Near	 0350	  _TEXT	Length= 000D Public C
cursoron . . . . . . . . . . . .	P Near	 035D	  _TEXT	Length= 000F Public C
delay  . . . . . . . . . . . . .	P Near	 036C	  _TEXT	Length= 0015 Public C
  ms . . . . . . . . . . . . . .	Word	 bp + 0004
drawline . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
getchar  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
getche . . . . . . . . . . . . .	P Near	 0007	  _TEXT	Length= 000B Public C
getch  . . . . . . . . . . . . .	P Near	 0000	  _TEXT	Length= 0007 Public C
gets . . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
gotoxy . . . . . . . . . . . . .	P Near	 0049	  _TEXT	Length= 0011 Public C
  x  . . . . . . . . . . . . . .	Byte	 bp + 0004
  y  . . . . . . . . . . . . . .	Byte	 bp + 0006
highvideo  . . . . . . . . . . .	P Near	 005A	  _TEXT	Length= 000D Public C
insline  . . . . . . . . . . . .	P Near	 0074	  _TEXT	Length= 000B Public C
isalnum  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
isalpha  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
iscntrl  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
isdigit  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
isgraph  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
islower  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
isprint  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
ispunct  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
isspace  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
isupper  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
isxdigit . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
kbhit  . . . . . . . . . . . . .	P Near	 0012	  _TEXT	Length= 0008 Public C
localtime  . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
lowvideo . . . . . . . . . . . .	P Near	 0067	  _TEXT	Length= 000D Public C
memchr . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
memcmp . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
memcpy . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
memmove  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
memset . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
newline  . . . . . . . . . . . .	P Near	 0381	  _TEXT	Length= 000D Public C
printf . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
putchar  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
putch  . . . . . . . . . . . . .	P Near	 001A	  _TEXT	Length= 0018 Public C
  n  . . . . . . . . . . . . . .	Word	 bp + 0004
puts . . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
raise  . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
scanf  . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
setcursortype  . . . . . . . . .	P Near	 038E	  _TEXT	Length= 0014 Public C
  cur  . . . . . . . . . . . . .	Byte	 bp + 0004
signal . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strcat . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strchr . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strcmp . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strcoll  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strcpy . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strcspn  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strlen . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strncat  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strncmp  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strncpy  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strpbrk  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strrchr  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strspn . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strstr . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strtok . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strxfrm  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
textbackground . . . . . . . . .	P Near	 0336	  _TEXT	Length= 000D Public C
  color  . . . . . . . . . . . .	Byte	 bp + 0004
textcolor  . . . . . . . . . . .	P Near	 0343	  _TEXT	Length= 000D Public C
  color  . . . . . . . . . . . .	Byte	 bp + 0004
tolower  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
toupper  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
ungetch  . . . . . . . . . . . .	P Near	 0032	  _TEXT	Length= 0010 Public C
  n  . . . . . . . . . . . . . .	Word	 bp + 0004
wherex . . . . . . . . . . . . .	P Near	 007F	  _TEXT	Length= 000F Public C
wherey . . . . . . . . . . . . .	P Near	 008E	  _TEXT	Length= 000F Public C


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0001h	 
@Model . . . . . . . . . . . . .	Number	 0001h	 
@code  . . . . . . . . . . . . .	Text   	 DGROUP
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
BUFSIZ . . . . . . . . . . . . .	Number	 1000h	 
FILENAME_MAX . . . . . . . . . .	Number	 000Bh	 
NSIG . . . . . . . . . . . . . .	Number	 0017h	 
SIGABRT  . . . . . . . . . . . .	Number	 0016h	 
SIGBREAK . . . . . . . . . . . .	Number	 0015h	 
SIGFPE . . . . . . . . . . . . .	Number	 0008h	 
SIGILL . . . . . . . . . . . . .	Number	 0004h	 
SIGINT . . . . . . . . . . . . .	Number	 0002h	 
SIGSEGV  . . . . . . . . . . . .	Number	 000Bh	 
SIGTERM  . . . . . . . . . . . .	Number	 000Fh	 
_ASSERT_ . . . . . . . . . . . .	Text   	 1
_CONIO_  . . . . . . . . . . . .	Text   	 1
_CTYPE_  . . . . . . . . . . . .	Text   	 1
_SIGNAL_ . . . . . . . . . . . .	Text   	 1
_STDBOOL_  . . . . . . . . . . .	Text   	 1
_STDIO_  . . . . . . . . . . . .	Text   	 1
_STRING_ . . . . . . . . . . . .	Text   	 1
_TIME_ . . . . . . . . . . . . .	Text   	 1
buffered . . . . . . . . . . . .	Byte	 0002	  _DATA	
false  . . . . . . . . . . . . .	Number	 0000h	 
hexstr . . . . . . . . . . . . .	Byte	 0042	  _DATA	
outstr16 . . . . . . . . . . . .	Byte	 0052	  _DATA	
true . . . . . . . . . . . . . .	Number	 0001h	 
txtbg  . . . . . . . . . . . . .	Byte	 0001	  _DATA	
txtc . . . . . . . . . . . . . .	Byte	 0000	  _DATA	

	   0 Warnings
	   0 Errors
