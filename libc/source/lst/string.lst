Microsoft (R) Macro Assembler Version 6.15.8803		    09/07/17 22:04:37
source\string.asm					     Page 1 - 1


				; ------------------------------------------------------------------
				.model tiny, c							; Small memoy model
				.386								; 80386 CPU
				 include string.inc					; Include library headers
			      C .NOLIST
			      C IFNDEF _STRING_
 = 1			      C _STRING_ EQU <1>
			      C 
			      C memchr PROTO C :WORD, :BYTE, :PTR BYTE
			      C memcmp PROTO :WORD, :WORD, :PTR BYTE
			      C memcpy PROTO :WORD, :WORD, :PTR BYTE
			      C memmove PROTO :WORD, :WORD, :PTR BYTE
			      C memset PROTO :WORD, :BYTE, :PTR BYTE
			      C strcat PROTO :WORD, :WORD
			      C strchr PROTO :WORD, :BYTE
			      C strcmp PROTO :WORD, :WORD
			      C strcoll PROTO :WORD, :WORD
			      C strcpy PROTO :WORD, :WORD
			      C strcspn PROTO :WORD, :WORD
			      C strlen PROTO :WORD
			      C strncat PROTO :WORD, :WORD, :PTR BYTE	; [!] Warning! Mem error
			      C strncmp PROTO :WORD, :WORD, :PTR BYTE
			      C strncpy PROTO :WORD, :WORD, :PTR BYTE
			      C strpbrk PROTO :WORD, :WORD
			      C strrchr PROTO :WORD, :BYTE
			      C strspn PROTO :PTR WORD, :WORD
			      C strstr PROTO :WORD, :WORD
			      C strtok PROTO :WORD, :WORD
			      C strxfrm PROTO :WORD, :WORD, :PTR BYTE
			      C 
 0000			      C .data
 0000  0040 [		      C  return_buffer BYTE 64 dup(?)					; Buffer for returning data
        00
       ]
 0040  0040 [		      C  strtok_buffer BYTE 64 dup(?)					; Buffer for str token data
        00
       ]
 0080  0040 [		      C  token_buffer BYTE 64 dup(?)					; Buffer for str token data
        00
       ]
 0000			      C .code
			      C 
			      C ENDIF
			      C .LIST
			      C 
				 include conio.inc
			      C .NOLIST
			      C IFNDEF _CONIO_
 = 1			      C _CONIO_ EQU <1>
			      C 
			      C clrscr PROTO
			      C cprintf PROTO :WORD, :VARARG
			      C cputs PROTO :WORD
			      C cputsxy PROTO :BYTE, :BYTE, :WORD
			      C cscanf PROTO :WORD, :VARARG
			      C cursoroff PROTO
			      C cursoron PROTO
			      C delay PROTO :PTR BYTE
			      C drawline PROTO
			      C getch PROTO
			      C getche PROTO
			      C gotoxy PROTO :BYTE, :BYTE
			      C highvideo PROTO
			      C insline PROTO
			      C kbhit PROTO
			      C lowvideo PROTO
			      C newline	PROTO
			      C putch PROTO :BYTE
			      C setcursortype PROTO :BYTE
			      C textbackground PROTO :BYTE
			      C textcolor PROTO	:BYTE
			      C ungetch PROTO :BYTE
			      C wherex PROTO
			      C wherey PROTO
			      C 
 00C0			      C .data								; Data segment
 00C0 00		      C txtbg db 0							; Text background
 00C1  0040 [		      C buffered BYTE 64 dup(?)						; Buffer for returning data
        00
       ]
 0101 30 31 32 33 34 35	      C hexstr   db '0123456789ABCDEF'
       36 37 38 39 41 42
       43 44 45 46
 0111 30 30 00		      C outstr16   db '00', 0
 0000			      C .code
			      C 
			      C ENDIF
			      C .LIST
			      C 
				 include art.inc
 0000 0F 07 0F 08 0F 09	      C penImage BYTE 0fh, 07h, 0fh, 08h, 0fh, 09h, 0fh, 0ah, 0fh, 0eh, 0fh, 0fh, 0fh, 10h, 0fh, 11h, 10h, 06h, 10h, 07h
       0F 0A 0F 0E 0F 0F
       0F 10 0F 11 10 06
       10 07
 0014  10 08 10 09 10 0A      C 	 BYTE 10h, 08h, 10h, 09h, 10h, 0ah, 10h, 0bh, 10h, 0dh, 10h, 0eh, 10h, 0fh, 10h, 10h, 10h, 11h, 10h, 12h
       10 0B 10 0D 10 0E
       10 0F 10 10 10 11
       10 12
 0028  11 06 11 07 11 08      C 	 BYTE 11h, 06h, 11h, 07h, 11h, 08h, 11h, 09h, 11h, 0ah, 11h, 0bh, 11h, 0dh, 11h, 0eh, 11h, 0fh, 11h, 10h
       11 09 11 0A 11 0B
       11 0D 11 0E 11 0F
       11 10
 003C  11 11 11 12 11 13      C 	 BYTE 11h, 11h, 11h, 12h, 11h, 13h, 12h, 05h, 12h, 06h, 12h, 07h, 12h, 0ah, 12h, 0bh, 12h, 0ch, 12h, 0dh
       12 05 12 06 12 07
       12 0A 12 0B 12 0C
       12 0D
 0050  12 0E 12 11 12 12      C 	 BYTE 12h, 0eh, 12h, 11h, 12h, 12h, 12h, 13h, 13h, 05h, 13h, 06h, 13h, 0ah, 13h, 0bh, 13h, 0ch, 13h, 0dh
       12 13 13 05 13 06
       13 0A 13 0B 13 0C
       13 0D
 0064  13 12 13 13 14 05      C 	 BYTE 13h, 12h, 13h, 13h, 14h, 05h, 14h, 06h, 14h, 0bh, 14h, 0ch, 14h, 0dh, 14h, 12h, 14h, 13h, 15h, 05h
       14 06 14 0B 14 0C
       14 0D 14 12 14 13
       15 05
 0078  15 06 15 0B 15 0C      C 	 BYTE 15h, 06h, 15h, 0bh, 15h, 0ch, 15h, 0dh, 15h, 12h, 15h, 13h, 16h, 05h, 16h, 06h, 16h, 07h, 16h, 0ah
       15 0D 15 12 15 13
       16 05 16 06 16 07
       16 0A
 008C  16 0B 16 0C 16 0D      C 	 BYTE 16h, 0bh, 16h, 0ch, 16h, 0dh, 16h, 0eh, 16h, 11h, 16h, 12h, 16h, 13h, 17h, 05h, 17h, 06h, 17h, 07h
       16 0E 16 11 16 12
       16 13 17 05 17 06
       17 07
 00A0  17 08 17 09 17 0A      C 	 BYTE 17h, 08h, 17h, 09h, 17h, 0ah, 17h, 0bh, 17h, 0ch, 17h, 0dh, 17h, 0eh, 17h, 0fh, 17h, 10h, 17h, 11h
       17 0B 17 0C 17 0D
       17 0E 17 0F 17 10
       17 11
 00B4  17 12 18 06 18 07      C 	 BYTE 17h, 12h, 18h, 06h, 18h, 07h, 18h, 08h, 18h, 09h, 18h, 0ah, 18h, 0dh, 18h, 0eh, 18h, 0fh, 18h, 10h
       18 08 18 09 18 0A
       18 0D 18 0E 18 0F
       18 10
 00C8  18 11 18 12 19 07      C 	 BYTE 18h, 11h, 18h, 12h, 19h, 07h, 19h, 08h, 19h, 09h, 19h, 0eh, 19h, 0fh, 19h, 10h, 19h, 11h, 1bh, 0ah
       19 08 19 09 19 0E
       19 0F 19 10 19 11
       1B 0A
 00DC  1B 0B 1B 0E 1B 0F      C 	 BYTE 1bh, 0bh, 1bh, 0eh, 1bh, 0fh, 1ch, 0ah, 1ch, 0bh, 1ch, 0eh, 1ch, 0fh, 1dh, 0ah, 1dh, 0bh, 1dh, 0eh
       1C 0A 1C 0B 1C 0E
       1C 0F 1D 0A 1D 0B
       1D 0E
 00F0  1D 0F 1E 0A 1E 0B      C 	 BYTE 1dh, 0fh, 1eh, 0ah, 1eh, 0bh, 1eh, 0eh, 1eh, 0fh, 1fh, 0ah, 1fh, 0bh, 1fh, 0eh, 1fh, 0fh, 20h, 0ah
       1E 0E 1E 0F 1F 0A
       1F 0B 1F 0E 1F 0F
       20 0A
 0104  20 0B 20 0E 20 0F      C 	 BYTE 20h, 0bh, 20h, 0eh, 20h, 0fh, 21h, 0ah, 21h, 0bh, 21h, 0eh, 21h, 0fh, 22h, 0ah, 22h, 0bh, 22h, 0eh
       21 0A 21 0B 21 0E
       21 0F 22 0A 22 0B
       22 0E
 0118  22 0F 23 0A 23 0B      C 	 BYTE 22h, 0fh, 23h, 0ah, 23h, 0bh, 23h, 0eh, 23h, 0fh, 24h, 0ah, 24h, 0bh, 24h, 0eh, 24h, 0fh, 27h, 0ah
       23 0E 23 0F 24 0A
       24 0B 24 0E 24 0F
       27 0A
 012C  27 0B 27 0E 27 0F      C 	 BYTE 27h, 0bh, 27h, 0eh, 27h, 0fh, 28h, 0ah, 28h, 0bh, 28h, 0eh, 28h, 0fh, 29h, 0ah, 29h, 0bh, 29h, 0eh
       28 0A 28 0B 28 0E
       28 0F 29 0A 29 0B
       29 0E
 0140  29 0F 2A 0A 2A 0B      C 	 BYTE 29h, 0fh, 2ah, 0ah, 2ah, 0bh, 2ah, 0eh, 2ah, 0fh, 2bh, 0ah, 2bh, 0bh, 2bh, 0eh, 2bh, 0fh, 2ch, 0ah
       2A 0E 2A 0F 2B 0A
       2B 0B 2B 0E 2B 0F
       2C 0A
 0154  2C 0B 2C 0E 2C 0F      C 	 BYTE 2ch, 0bh, 2ch, 0eh, 2ch, 0fh, 2dh, 0ah, 2dh, 0bh, 2dh, 0eh, 2dh, 0fh, 2eh, 0ah, 2eh, 0bh, 2eh, 0eh
       2D 0A 2D 0B 2D 0E
       2D 0F 2E 0A 2E 0B
       2E 0E
 0168  2E 0F 2F 0A 2F 0B      C 	 BYTE 2eh, 0fh, 2fh, 0ah, 2fh, 0bh, 2fh, 0eh, 2fh, 0fh, 30h, 0ah, 30h, 0bh, 30h, 0eh, 30h, 0fh, 34h, 05h
       2F 0E 2F 0F 30 0A
       30 0B 30 0E 30 0F
       34 05
 017C  34 06 34 07 34 08      C 	 BYTE 34h, 06h, 34h, 07h, 34h, 08h, 34h, 09h, 34h, 0ah, 34h, 0bh, 34h, 0ch, 34h, 0dh, 34h, 0eh, 34h, 0fh
       34 09 34 0A 34 0B
       34 0C 34 0D 34 0E
       34 0F
 0190  34 10 34 11 34 12      C 	 BYTE 34h, 10h, 34h, 11h, 34h, 12h, 34h, 13h, 35h, 05h, 35h, 06h, 35h, 07h, 35h, 08h, 35h, 09h, 35h, 0ah
       34 13 35 05 35 06
       35 07 35 08 35 09
       35 0A
 01A4  35 0B 35 0C 35 0D      C 	 BYTE 35h, 0bh, 35h, 0ch, 35h, 0dh, 35h, 0eh, 35h, 0fh, 35h, 10h, 35h, 11h, 35h, 12h, 35h, 13h, 36h, 05h
       35 0E 35 0F 35 10
       35 11 35 12 35 13
       36 05
 01B8  36 06 36 07 36 08      C 	 BYTE 36h, 06h, 36h, 07h, 36h, 08h, 36h, 09h, 36h, 0ah, 36h, 0bh, 36h, 0ch, 36h, 0dh, 36h, 0eh, 36h, 0fh
       36 09 36 0A 36 0B
       36 0C 36 0D 36 0E
       36 0F
 01CC  36 10 36 11 36 12      C 	 BYTE 36h, 10h, 36h, 11h, 36h, 12h, 36h, 13h, 37h, 05h, 37h, 06h, 37h, 12h, 37h, 13h, 38h, 05h, 38h, 06h
       36 13 37 05 37 06
       37 12 37 13 38 05
       38 06
 01E0  38 12 38 13 39 05      C 	 BYTE 38h, 12h, 38h, 13h, 39h, 05h, 39h, 06h, 39h, 12h, 39h, 13h, 3ah, 05h, 3ah, 06h, 3ah, 12h, 3ah, 13h
       39 06 39 12 39 13
       3A 05 3A 06 3A 12
       3A 13
 01F4  3B 05 3B 06 3B 07      C 	 BYTE 3bh, 05h, 3bh, 06h, 3bh, 07h, 3bh, 11h, 3bh, 12h, 3bh, 13h, 3ch, 05h, 3ch, 06h, 3ch, 07h, 3ch, 11h
       3B 11 3B 12 3B 13
       3C 05 3C 06 3C 07
       3C 11
 0208  3C 12 3D 06 3D 07      C 	 BYTE 3ch, 12h, 3dh, 06h, 3dh, 07h, 3dh, 08h, 3dh, 09h, 3dh, 0fh, 3dh, 10h, 3dh, 11h, 3dh, 12h, 3eh, 06h
       3D 08 3D 09 3D 0F
       3D 10 3D 11 3D 12
       3E 06
 021C  3E 07 3E 08 3E 09      C 	 BYTE 3eh, 07h, 3eh, 08h, 3eh, 09h, 3eh, 0ah, 3eh, 0bh, 3eh, 0ch, 3eh, 0dh, 3eh, 0eh, 3eh, 0fh, 3eh, 10h
       3E 0A 3E 0B 3E 0C
       3E 0D 3E 0E 3E 0F
       3E 10
 0230  3E 11 3F 07 3F 08      C 	 BYTE 3eh, 11h, 3fh, 07h, 3fh, 08h, 3fh, 09h, 3fh, 0ah, 3fh, 0bh, 3fh, 0ch, 3fh, 0dh, 3fh, 0eh, 3fh, 0fh
       3F 09 3F 0A 3F 0B
       3F 0C 3F 0D 3F 0E
       3F 0F
 0244  3F 10 40 09 40 0A      C 	 BYTE 3fh, 10h, 40h, 09h, 40h, 0ah, 40h, 0bh, 40h, 0ch, 40h, 0dh, 40h, 0eh, 40h, 0fh
       40 0B 40 0C 40 0D
       40 0E 40 0F
 = 012A			      C 	 penSize EQU 12ah
			      C 
 0254 1E 0A 07 1E 0B 04	      C derpImage BYTE 1eh, 0ah, 07h, 1eh, 0bh, 04h, 1eh, 0ch, 08h, 1eh, 0dh, 09h, 1eh, 0eh, 01h, 1eh, 0fh, 0bh, 1eh, 10h
       1E 0C 08 1E 0D 09
       1E 0E 01 1E 0F 0B
       1E 10
 0268  08 1E 11 02 1E 12      C 	 BYTE 08h, 1eh, 11h, 02h, 1eh, 12h, 01h, 1fh, 07h, 09h, 1fh, 08h, 0ch, 1fh, 09h, 0dh, 1fh, 0ah, 0eh, 1fh
       01 1F 07 09 1F 08
       0C 1F 09 0D 1F 0A
       0E 1F
 027C  12 02 1F 13 01 1F      C 	 BYTE 12h, 02h, 1fh, 13h, 01h, 1fh, 14h, 0ah, 1fh, 15h, 0bh, 20h, 06h, 04h, 20h, 07h, 0bh, 20h, 15h, 0ch
       14 0A 1F 15 0B 20
       06 04 20 07 0B 20
       15 0C
 0290  20 16 01 21 05 08      C 	 BYTE 20h, 16h, 01h, 21h, 05h, 08h, 21h, 06h, 0ah, 21h, 09h, 05h, 21h, 0ah, 0ch, 21h, 0bh, 05h, 21h, 0ch
       21 06 0A 21 09 05
       21 0A 0C 21 0B 05
       21 0C
 02A4  03 21 15 0D 21 16      C 	 BYTE 03h, 21h, 15h, 0dh, 21h, 16h, 0eh, 21h, 17h, 04h, 22h, 04h, 03h, 22h, 05h, 06h, 22h, 08h, 0bh, 22h
       0E 21 17 04 22 04
       03 22 05 06 22 08
       0B 22
 02B8  09 08 22 0A 08 22      C 	 BYTE 09h, 08h, 22h, 0ah, 08h, 22h, 0bh, 0eh, 22h, 0dh, 04h, 22h, 17h, 0bh, 23h, 03h, 08h, 23h, 04h, 05h
       0B 0E 22 0D 04 22
       17 0B 23 03 08 23
       04 05
 02CC  23 07 02 23 09 07      C 	 BYTE 23h, 07h, 02h, 23h, 09h, 07h, 23h, 0ah, 05h, 23h, 0bh, 01h, 23h, 0dh, 07h, 23h, 17h, 08h, 24h, 02h
       23 0A 05 23 0B 01
       23 0D 07 23 17 08
       24 02
 02E0  09 24 03 08 24 07      C 	 BYTE 09h, 24h, 03h, 08h, 24h, 07h, 06h, 24h, 0dh, 0ch, 25h, 01h, 06h, 25h, 02h, 0bh, 25h, 07h, 0bh, 25h
       06 24 0D 0C 25 01
       06 25 02 0B 25 07
       0B 25
 02F4  0D 08 26 01 05 26      C 	 BYTE 0dh, 08h, 26h, 01h, 05h, 26h, 02h, 01h, 26h, 08h, 06h, 26h, 0ch, 05h, 26h, 0fh, 02h, 26h, 10h, 0ch
       02 01 26 08 06 26
       0C 05 26 0F 02 26
       10 0C
 0308  27 00 06 27 01 03      C 	 BYTE 27h, 00h, 06h, 27h, 01h, 03h, 27h, 02h, 0ah, 27h, 09h, 0ch, 27h, 0ah, 0ch, 27h, 0bh, 02h, 27h, 0fh
       27 02 0A 27 09 0C
       27 0A 0C 27 0B 02
       27 0F
 031C  01 27 10 06 27 11      C 	 BYTE 01h, 27h, 10h, 06h, 27h, 11h, 03h, 28h, 00h, 05h, 28h, 01h, 0dh, 28h, 0fh, 03h, 28h, 10h, 0bh, 28h
       03 28 00 05 28 01
       0D 28 0F 03 28 10
       0B 28
 0330  11 07 28 12 0D 28      C 	 BYTE 11h, 07h, 28h, 12h, 0dh, 28h, 13h, 06h, 29h, 00h, 05h, 29h, 01h, 08h, 29h, 0fh, 0bh, 29h, 10h, 09h
       13 06 29 00 05 29
       01 08 29 0F 0B 29
       10 09
 0344  29 13 0E 29 14 02      C 	 BYTE 29h, 13h, 0eh, 29h, 14h, 02h, 2ah, 00h, 0eh, 2ah, 01h, 02h, 2ah, 07h, 04h, 2ah, 08h, 04h, 2ah, 09h
       2A 00 0E 2A 01 02
       2A 07 04 2A 08 04
       2A 09
 0358  03 2A 13 0B 2A 14      C 	 BYTE 03h, 2ah, 13h, 0bh, 2ah, 14h, 05h, 2bh, 00h, 02h, 2bh, 01h, 05h, 2bh, 06h, 05h, 2bh, 09h, 09h, 2bh
       05 2B 00 02 2B 01
       05 2B 06 05 2B 09
       09 2B
 036C  0A 03 2B 13 0C 2B      C 	 BYTE 0ah, 03h, 2bh, 13h, 0ch, 2bh, 14h, 0ch, 2ch, 00h, 02h, 2ch, 01h, 07h, 2ch, 05h, 07h, 2ch, 0ah, 06h
       14 0C 2C 00 02 2C
       01 07 2C 05 07 2C
       0A 06
 0380  2C 0B 0B 2C 0E 04      C 	 BYTE 2ch, 0bh, 0bh, 2ch, 0eh, 04h, 2ch, 0fh, 01h, 2ch, 13h, 01h, 2ch, 14h, 0dh, 2dh, 01h, 0ch, 2dh, 05h
       2C 0F 01 2C 13 01
       2C 14 0D 2D 01 0C
       2D 05
 0394  0C 2D 0B 01 2D 0E      C 	 BYTE 0ch, 2dh, 0bh, 01h, 2dh, 0eh, 0eh, 2dh, 0fh, 0eh, 2dh, 10h, 02h, 2dh, 11h, 03h, 2dh, 12h, 0ah, 2dh
       0E 2D 0F 0E 2D 10
       02 2D 11 03 2D 12
       0A 2D
 03A8  13 02 2D 14 05 2E      C 	 BYTE 13h, 02h, 2dh, 14h, 05h, 2eh, 01h, 05h, 2eh, 02h, 01h, 2eh, 05h, 09h, 2eh, 06h, 05h, 2eh, 07h, 0eh
       01 05 2E 02 01 2E
       05 09 2E 06 05 2E
       07 0E
 03BC  2E 0B 03 2E 0E 0D      C 	 BYTE 2eh, 0bh, 03h, 2eh, 0eh, 0dh, 2eh, 0fh, 06h, 2eh, 10h, 05h, 2eh, 11h, 0bh, 2eh, 12h, 02h, 2eh, 13h
       2E 0F 06 2E 10 05
       2E 11 0B 2E 12 02
       2E 13
 03D0  09 2F 02 07 2F 03      C 	 BYTE 09h, 2fh, 02h, 07h, 2fh, 03h, 03h, 2fh, 06h, 04h, 2fh, 07h, 04h, 2fh, 0bh, 09h, 30h, 03h, 02h, 30h
       03 2F 06 04 2F 07
       04 2F 0B 09 30 03
       02 30
 03E4  04 0A 30 08 01 30      C 	 BYTE 04h, 0ah, 30h, 08h, 01h, 30h, 0ah, 03h, 30h, 0bh, 09h, 31h, 04h, 0eh, 31h, 05h, 0dh, 31h, 06h, 09h
       0A 03 30 0B 09 31
       04 0E 31 05 0D 31
       06 09
 03F8  31 09 0C 31 0A 09      C 	 BYTE 31h, 09h, 0ch, 31h, 0ah, 09h, 32h, 06h, 04h, 32h, 07h, 08h, 32h, 08h, 0ah, 32h, 17h, 0dh, 33h, 08h
       32 06 04 32 07 08
       32 08 0A 32 17 0D
       33 08
 040C  06 33 09 07 33 0A      C 	 BYTE 06h, 33h, 09h, 07h, 33h, 0ah, 0ah, 33h, 0bh, 0ah, 33h, 0ch, 08h, 33h, 0dh, 07h, 33h, 0eh, 08h, 33h
       0A 33 0B 0A 33 0C
       08 33 0D 07 33 0E
       08 33
 0420  0F 04 33 10 0B 33      C 	 BYTE 0fh, 04h, 33h, 10h, 0bh, 33h, 11h, 0ah, 33h, 14h, 07h, 33h, 15h, 01h, 33h, 16h, 09h, 33h, 17h, 01h
       11 0A 33 14 07 33
       15 01 33 16 09 33
       17 01
 0434  34 0B 0A 34 0C 08      C 	 BYTE 34h, 0bh, 0ah, 34h, 0ch, 08h, 34h, 0dh, 0dh, 34h, 0eh, 0dh, 34h, 0fh, 01h, 34h, 10h, 02h, 34h, 11h
       34 0D 0D 34 0E 0D
       34 0F 01 34 10 02
       34 11
 0448  0E 34 12 04 34 13      C 	 BYTE 0eh, 34h, 12h, 04h, 34h, 13h, 03h, 34h, 14h, 04h
       03 34 14 04
 = 00FF			      C 	 derpSize EQU 00ffh
			      C 
 0452 08 05 02 08 06 0D	      C memesImage BYTE 08h, 05h, 02h, 08h, 06h, 0dh, 08h, 07h, 09h, 08h, 08h, 05h, 08h, 09h, 0dh, 08h, 0ah, 08h, 08h, 0bh
       08 07 09 08 08 05
       08 09 0D 08 0A 08
       08 0B
 0466  08 08 0C 06 08 0D      C 	 BYTE 08h, 08h, 0ch, 06h, 08h, 0dh, 03h, 08h, 0eh, 0bh, 08h, 0fh, 02h, 08h, 10h, 06h, 08h, 11h, 03h, 09h
       03 08 0E 0B 08 0F
       02 08 10 06 08 11
       03 09
 047A  05 08 09 06 05 09      C 	 BYTE 05h, 08h, 09h, 06h, 05h, 09h, 07h, 05h, 09h, 08h, 0dh, 09h, 09h, 07h, 09h, 0ah, 0bh, 09h, 0bh, 04h
       07 05 09 08 0D 09
       09 07 09 0A 0B 09
       0B 04
 048E  09 0C 03 09 0D 0C      C 	 BYTE 09h, 0ch, 03h, 09h, 0dh, 0ch, 09h, 0eh, 07h, 09h, 0fh, 0bh, 09h, 10h, 03h, 09h, 11h, 07h, 0ah, 05h
       09 0E 07 09 0F 0B
       09 10 03 09 11 07
       0A 05
 04A2  09 0A 06 05 0A 07      C 	 BYTE 09h, 0ah, 06h, 05h, 0ah, 07h, 03h, 0ah, 08h, 02h, 0ah, 09h, 03h, 0ah, 0ah, 04h, 0ah, 0bh, 03h, 0ah
       03 0A 08 02 0A 09
       03 0A 0A 04 0A 0B
       03 0A
 04B6  0C 0E 0A 0D 0E 0A      C 	 BYTE 0ch, 0eh, 0ah, 0dh, 0eh, 0ah, 0eh, 08h, 0ah, 0fh, 06h, 0ah, 10h, 0bh, 0ah, 11h, 0bh, 0bh, 05h, 05h
       0E 08 0A 0F 06 0A
       10 0B 0A 11 0B 0B
       05 05
 04CA  0B 06 09 0B 07 0B      C 	 BYTE 0bh, 06h, 09h, 0bh, 07h, 0bh, 0bh, 08h, 0eh, 0ch, 05h, 08h, 0ch, 06h, 0ch, 0ch, 07h, 0eh, 0ch, 08h
       0B 08 0E 0C 05 08
       0C 06 0C 0C 07 0E
       0C 08
 04DE  02 0C 09 0A 0C 0A      C 	 BYTE 02h, 0ch, 09h, 0ah, 0ch, 0ah, 05h, 0ch, 0bh, 06h, 0dh, 07h, 08h, 0dh, 08h, 07h, 0dh, 09h, 09h, 0dh
       05 0C 0B 06 0D 07
       08 0D 08 07 0D 09
       09 0D
 04F2  0A 02 0D 0B 06 0D      C 	 BYTE 0ah, 02h, 0dh, 0bh, 06h, 0dh, 0ch, 08h, 0dh, 0dh, 02h, 0dh, 0eh, 0ah, 0dh, 0fh, 09h, 0eh, 0bh, 05h
       0C 08 0D 0D 02 0D
       0E 0A 0D 0F 09 0E
       0B 05
 0506  0E 0C 01 0E 0D 03      C 	 BYTE 0eh, 0ch, 01h, 0eh, 0dh, 03h, 0eh, 0eh, 05h, 0eh, 0fh, 05h, 0eh, 10h, 06h, 0eh, 11h, 04h, 0fh, 0eh
       0E 0E 05 0E 0F 05
       0E 10 06 0E 11 04
       0F 0E
 051A  0B 0F 0F 08 0F 10      C 	 BYTE 0bh, 0fh, 0fh, 08h, 0fh, 10h, 03h, 0fh, 11h, 01h, 10h, 0bh, 0ch, 10h, 0ch, 0ah, 10h, 0dh, 05h, 10h
       03 0F 11 01 10 0B
       0C 10 0C 0A 10 0D
       05 10
 052E  0E 0A 10 0F 01 10      C 	 BYTE 0eh, 0ah, 10h, 0fh, 01h, 10h, 10h, 03h, 10h, 11h, 0bh, 11h, 08h, 05h, 11h, 09h, 02h, 11h, 0ah, 01h
       10 03 10 11 0B 11
       08 05 11 09 02 11
       0A 01
 0542  11 0B 06 11 0C 09      C 	 BYTE 11h, 0bh, 06h, 11h, 0ch, 09h, 11h, 0dh, 0eh, 11h, 0eh, 01h, 12h, 05h, 0dh, 12h, 06h, 0eh, 12h, 07h
       11 0D 0E 11 0E 01
       12 05 0D 12 06 0E
       12 07
 0556  07 12 08 0D 12 09      C 	 BYTE 07h, 12h, 08h, 0dh, 12h, 09h, 03h, 12h, 0ah, 0ah, 12h, 0bh, 06h, 13h, 05h, 09h, 13h, 06h, 08h, 13h
       03 12 0A 0A 12 0B
       06 13 05 09 13 06
       08 13
 056A  07 07 13 08 06 14      C 	 BYTE 07h, 07h, 13h, 08h, 06h, 14h, 05h, 0eh, 14h, 06h, 02h, 14h, 07h, 0eh, 14h, 08h, 03h, 14h, 09h, 08h
       05 0E 14 06 02 14
       07 0E 14 08 03 14
       09 08
 057E  14 0A 04 14 0B 0B      C 	 BYTE 14h, 0ah, 04h, 14h, 0bh, 0bh, 14h, 0ch, 0bh, 14h, 0dh, 03h, 14h, 0eh, 05h, 14h, 0fh, 02h, 14h, 10h
       14 0C 0B 14 0D 03
       14 0E 05 14 0F 02
       14 10
 0592  0E 14 11 04 15 05      C 	 BYTE 0eh, 14h, 11h, 04h, 15h, 05h, 02h, 15h, 06h, 08h, 15h, 07h, 07h, 15h, 08h, 01h, 15h, 09h, 08h, 15h
       02 15 06 08 15 07
       07 15 08 01 15 09
       08 15
 05A6  0A 03 15 0B 0A 15      C 	 BYTE 0ah, 03h, 15h, 0bh, 0ah, 15h, 0ch, 0ch, 15h, 0dh, 02h, 15h, 0eh, 03h, 15h, 0fh, 05h, 15h, 10h, 0dh
       0C 0C 15 0D 02 15
       0E 03 15 0F 05 15
       10 0D
 05BA  15 11 0B 16 05 0D      C 	 BYTE 15h, 11h, 0bh, 16h, 05h, 0dh, 16h, 06h, 0dh, 16h, 07h, 05h, 16h, 08h, 07h, 16h, 09h, 02h, 16h, 0ah
       16 06 0D 16 07 05
       16 08 07 16 09 02
       16 0A
 05CE  02 16 0B 07 16 0C      C 	 BYTE 02h, 16h, 0bh, 07h, 16h, 0ch, 09h, 16h, 0dh, 08h, 16h, 0eh, 0eh, 16h, 0fh, 0dh, 16h, 10h, 0bh, 16h
       09 16 0D 08 16 0E
       0E 16 0F 0D 16 10
       0B 16
 05E2  11 02 1A 05 05 1A      C 	 BYTE 11h, 02h, 1ah, 05h, 05h, 1ah, 06h, 08h, 1ah, 07h, 0dh, 1ah, 08h, 04h, 1ah, 09h, 05h, 1ah, 0ah, 0dh
       06 08 1A 07 0D 1A
       08 04 1A 09 05 1A
       0A 0D
 05F6  1A 0B 0C 1A 0C 0D      C 	 BYTE 1ah, 0bh, 0ch, 1ah, 0ch, 0dh, 1ah, 0dh, 09h, 1ah, 0eh, 0bh, 1ah, 0fh, 0ch, 1ah, 10h, 07h, 1ah, 11h
       1A 0D 09 1A 0E 0B
       1A 0F 0C 1A 10 07
       1A 11
 060A  02 1B 05 0A 1B 06      C 	 BYTE 02h, 1bh, 05h, 0ah, 1bh, 06h, 03h, 1bh, 07h, 04h, 1bh, 08h, 0ah, 1bh, 09h, 04h, 1bh, 0ah, 07h, 1bh
       03 1B 07 04 1B 08
       0A 1B 09 04 1B 0A
       07 1B
 061E  0B 08 1B 0C 02 1B      C 	 BYTE 0bh, 08h, 1bh, 0ch, 02h, 1bh, 0dh, 0bh, 1bh, 0eh, 01h, 1bh, 0fh, 08h, 1bh, 10h, 04h, 1bh, 11h, 0bh
       0D 0B 1B 0E 01 1B
       0F 08 1B 10 04 1B
       11 0B
 0632  1C 05 03 1C 06 0A      C 	 BYTE 1ch, 05h, 03h, 1ch, 06h, 0ah, 1ch, 07h, 05h, 1ch, 08h, 01h, 1ch, 09h, 0bh, 1ch, 0ah, 05h, 1ch, 0bh
       1C 07 05 1C 08 01
       1C 09 0B 1C 0A 05
       1C 0B
 0646  04 1C 0C 06 1C 0D      C 	 BYTE 04h, 1ch, 0ch, 06h, 1ch, 0dh, 02h, 1ch, 0eh, 0eh, 1ch, 0fh, 0ah, 1ch, 10h, 0ch, 1ch, 11h, 04h, 1dh
       02 1C 0E 0E 1C 0F
       0A 1C 10 0C 1C 11
       04 1D
 065A  05 0C 1D 06 03 1D      C 	 BYTE 05h, 0ch, 1dh, 06h, 03h, 1dh, 0ah, 06h, 1dh, 0bh, 0ch, 1dh, 10h, 0bh, 1dh, 11h, 0eh, 1eh, 05h, 07h
       0A 06 1D 0B 0C 1D
       10 0B 1D 11 0E 1E
       05 07
 066E  1E 06 02 1E 0A 0E      C 	 BYTE 1eh, 06h, 02h, 1eh, 0ah, 0eh, 1eh, 0bh, 01h, 1eh, 10h, 0bh, 1eh, 11h, 05h, 1fh, 05h, 08h, 1fh, 06h
       1E 0B 01 1E 10 0B
       1E 11 05 1F 05 08
       1F 06
 0682  0D 1F 0A 02 1F 0B      C 	 BYTE 0dh, 1fh, 0ah, 02h, 1fh, 0bh, 02h, 1fh, 10h, 0eh, 1fh, 11h, 01h, 20h, 05h, 0dh, 20h, 06h, 0bh, 20h
       02 1F 10 0E 1F 11
       01 20 05 0D 20 06
       0B 20
 0696  0A 07 20 0B 06 20      C 	 BYTE 0ah, 07h, 20h, 0bh, 06h, 20h, 10h, 04h, 20h, 11h, 04h, 21h, 05h, 0ah, 21h, 06h, 05h, 21h, 10h, 01h
       10 04 20 11 04 21
       05 0A 21 06 05 21
       10 01
 06AA  21 11 08 24 05 04      C 	 BYTE 21h, 11h, 08h, 24h, 05h, 04h, 24h, 06h, 07h, 24h, 07h, 03h, 24h, 08h, 0bh, 24h, 09h, 09h, 24h, 0ah
       24 06 07 24 07 03
       24 08 0B 24 09 09
       24 0A
 06BE  0C 24 0B 02 24 0C      C 	 BYTE 0ch, 24h, 0bh, 02h, 24h, 0ch, 04h, 24h, 0dh, 08h, 24h, 0eh, 0ah, 24h, 0fh, 08h, 24h, 10h, 0ah, 24h
       04 24 0D 08 24 0E
       0A 24 0F 08 24 10
       0A 24
 06D2  11 09 25 05 07 25      C 	 BYTE 11h, 09h, 25h, 05h, 07h, 25h, 06h, 0bh, 25h, 07h, 0bh, 25h, 08h, 04h, 25h, 09h, 05h, 25h, 0ah, 0bh
       06 0B 25 07 0B 25
       08 04 25 09 05 25
       0A 0B
 06E6  25 0B 04 25 0C 05      C 	 BYTE 25h, 0bh, 04h, 25h, 0ch, 05h, 25h, 0dh, 02h, 25h, 0eh, 04h, 25h, 0fh, 0bh, 25h, 10h, 06h, 25h, 11h
       25 0D 02 25 0E 04
       25 0F 0B 25 10 06
       25 11
 06FA  02 26 05 0B 26 06      C 	 BYTE 02h, 26h, 05h, 0bh, 26h, 06h, 03h, 26h, 07h, 08h, 26h, 08h, 02h, 26h, 09h, 03h, 26h, 0ah, 0ch, 26h
       03 26 07 08 26 08
       02 26 09 03 26 0A
       0C 26
 070E  0B 0E 26 0C 0D 26      C 	 BYTE 0bh, 0eh, 26h, 0ch, 0dh, 26h, 0dh, 0ch, 26h, 0eh, 0ah, 26h, 0fh, 08h, 26h, 10h, 0eh, 26h, 11h, 03h
       0D 0C 26 0E 0A 26
       0F 08 26 10 0E 26
       11 03
 0722  27 05 07 27 06 0C      C 	 BYTE 27h, 05h, 07h, 27h, 06h, 0ch, 27h, 07h, 06h, 27h, 08h, 02h, 28h, 05h, 03h, 28h, 06h, 08h, 28h, 07h
       27 07 06 27 08 02
       28 05 03 28 06 08
       28 07
 0736  01 28 08 0A 28 09      C 	 BYTE 01h, 28h, 08h, 0ah, 28h, 09h, 08h, 28h, 0ah, 0ah, 28h, 0bh, 01h, 29h, 07h, 0dh, 29h, 08h, 0ch, 29h
       08 28 0A 0A 28 0B
       01 29 07 0D 29 08
       0C 29
 074A  09 0E 29 0A 0C 29      C 	 BYTE 09h, 0eh, 29h, 0ah, 0ch, 29h, 0bh, 09h, 29h, 0ch, 08h, 29h, 0dh, 08h, 29h, 0eh, 08h, 29h, 0fh, 08h
       0B 09 29 0C 08 29
       0D 08 29 0E 08 29
       0F 08
 075E  2A 0B 0E 2A 0C 06      C 	 BYTE 2ah, 0bh, 0eh, 2ah, 0ch, 06h, 2ah, 0dh, 04h, 2ah, 0eh, 01h, 2ah, 0fh, 02h, 2ah, 10h, 03h, 2ah, 11h
       2A 0D 04 2A 0E 01
       2A 0F 02 2A 10 03
       2A 11
 0772  02 2B 0E 07 2B 0F      C 	 BYTE 02h, 2bh, 0eh, 07h, 2bh, 0fh, 08h, 2bh, 10h, 06h, 2bh, 11h, 03h, 2ch, 0bh, 0bh, 2ch, 0ch, 04h, 2ch
       08 2B 10 06 2B 11
       03 2C 0B 0B 2C 0C
       04 2C
 0786  0D 06 2C 0E 09 2C      C 	 BYTE 0dh, 06h, 2ch, 0eh, 09h, 2ch, 0fh, 01h, 2ch, 10h, 02h, 2ch, 11h, 05h, 2dh, 08h, 07h, 2dh, 09h, 0bh
       0F 01 2C 10 02 2C
       11 05 2D 08 07 2D
       09 0B
 079A  2D 0A 0A 2D 0B 0A      C 	 BYTE 2dh, 0ah, 0ah, 2dh, 0bh, 0ah, 2dh, 0ch, 0eh, 2dh, 0dh, 01h, 2dh, 0eh, 05h, 2eh, 05h, 09h, 2eh, 06h
       2D 0C 0E 2D 0D 01
       2D 0E 05 2E 05 09
       2E 06
 07AE  07 2E 07 01 2E 08      C 	 BYTE 07h, 2eh, 07h, 01h, 2eh, 08h, 03h, 2eh, 09h, 01h, 2eh, 0ah, 0ch, 2eh, 0bh, 0dh, 2fh, 05h, 08h, 2fh
       03 2E 09 01 2E 0A
       0C 2E 0B 0D 2F 05
       08 2F
 07C2  06 04 2F 07 0D 2F      C 	 BYTE 06h, 04h, 2fh, 07h, 0dh, 2fh, 08h, 0eh, 30h, 05h, 02h, 30h, 06h, 08h, 30h, 07h, 03h, 30h, 08h, 01h
       08 0E 30 05 02 30
       06 08 30 07 03 30
       08 01
 07D6  30 09 0C 30 0A 05      C 	 BYTE 30h, 09h, 0ch, 30h, 0ah, 05h, 30h, 0bh, 02h, 30h, 0ch, 04h, 30h, 0dh, 0eh, 30h, 0eh, 0ch, 30h, 0fh
       30 0B 02 30 0C 04
       30 0D 0E 30 0E 0C
       30 0F
 07EA  09 30 10 01 30 11      C 	 BYTE 09h, 30h, 10h, 01h, 30h, 11h, 0dh, 31h, 05h, 08h, 31h, 06h, 05h, 31h, 07h, 09h, 31h, 08h, 04h, 31h
       0D 31 05 08 31 06
       05 31 07 09 31 08
       04 31
 07FE  09 0A 31 0A 0C 31      C 	 BYTE 09h, 0ah, 31h, 0ah, 0ch, 31h, 0bh, 03h, 31h, 0ch, 02h, 31h, 0dh, 0eh, 31h, 0eh, 08h, 31h, 0fh, 03h
       0B 03 31 0C 02 31
       0D 0E 31 0E 08 31
       0F 03
 0812  31 10 0C 31 11 0E      C 	 BYTE 31h, 10h, 0ch, 31h, 11h, 0eh, 32h, 05h, 0eh, 32h, 06h, 05h, 32h, 07h, 02h, 32h, 08h, 01h, 32h, 09h
       32 05 0E 32 06 05
       32 07 02 32 08 01
       32 09
 0826  0B 32 0A 01 32 0B      C 	 BYTE 0bh, 32h, 0ah, 01h, 32h, 0bh, 02h, 32h, 0ch, 07h, 32h, 0dh, 0ch, 32h, 0eh, 01h, 32h, 0fh, 0eh, 32h
       02 32 0C 07 32 0D
       0C 32 0E 01 32 0F
       0E 32
 083A  10 08 32 11 07 36      C 	 BYTE 10h, 08h, 32h, 11h, 07h, 36h, 05h, 0eh, 36h, 06h, 06h, 36h, 07h, 04h, 36h, 08h, 09h, 36h, 09h, 03h
       05 0E 36 06 06 36
       07 04 36 08 09 36
       09 03
 084E  36 0A 01 36 0B 0A      C 	 BYTE 36h, 0ah, 01h, 36h, 0bh, 0ah, 36h, 0ch, 0bh, 36h, 0dh, 0eh, 36h, 0eh, 09h, 36h, 0fh, 07h, 36h, 10h
       36 0C 0B 36 0D 0E
       36 0E 09 36 0F 07
       36 10
 0862  0B 36 11 0E 37 05      C 	 BYTE 0bh, 36h, 11h, 0eh, 37h, 05h, 0dh, 37h, 06h, 03h, 37h, 07h, 0bh, 37h, 08h, 04h, 37h, 09h, 01h, 37h
       0D 37 06 03 37 07
       0B 37 08 04 37 09
       01 37
 0876  0A 09 37 0B 0D 37      C 	 BYTE 0ah, 09h, 37h, 0bh, 0dh, 37h, 0ch, 02h, 37h, 0dh, 09h, 37h, 0eh, 02h, 37h, 0fh, 09h, 37h, 10h, 07h
       0C 02 37 0D 09 37
       0E 02 37 0F 09 37
       10 07
 088A  37 11 07 38 05 05      C 	 BYTE 37h, 11h, 07h, 38h, 05h, 05h, 38h, 06h, 03h, 38h, 07h, 04h, 38h, 08h, 0eh, 38h, 09h, 05h, 38h, 0ah
       38 06 03 38 07 04
       38 08 0E 38 09 05
       38 0A
 089E  08 38 0B 05 38 0C      C 	 BYTE 08h, 38h, 0bh, 05h, 38h, 0ch, 0eh, 38h, 0dh, 05h, 38h, 0eh, 03h, 38h, 0fh, 0eh, 38h, 10h, 07h, 38h
       0E 38 0D 05 38 0E
       03 38 0F 0E 38 10
       07 38
 08B2  11 02 39 05 03 39      C 	 BYTE 11h, 02h, 39h, 05h, 03h, 39h, 06h, 0ch, 39h, 0ah, 0eh, 39h, 0bh, 02h, 39h, 10h, 08h, 39h, 11h, 03h
       06 0C 39 0A 0E 39
       0B 02 39 10 08 39
       11 03
 08C6  3A 05 07 3A 06 0B      C 	 BYTE 3ah, 05h, 07h, 3ah, 06h, 0bh, 3ah, 0ah, 04h, 3ah, 0bh, 0eh, 3ah, 10h, 0bh, 3ah, 11h, 0ch, 3bh, 05h
       3A 0A 04 3A 0B 0E
       3A 10 0B 3A 11 0C
       3B 05
 08DA  01 3B 06 0A 3B 0A      C 	 BYTE 01h, 3bh, 06h, 0ah, 3bh, 0ah, 0bh, 3bh, 0bh, 0bh, 3bh, 10h, 07h, 3bh, 11h, 07h, 3ch, 05h, 0dh, 3ch
       0B 3B 0B 0B 3B 10
       07 3B 11 07 3C 05
       0D 3C
 08EE  06 08 3C 0A 0B 3C      C 	 BYTE 06h, 08h, 3ch, 0ah, 0bh, 3ch, 0bh, 04h, 3ch, 10h, 06h, 3ch, 11h, 07h, 3dh, 05h, 08h, 3dh, 06h, 07h
       0B 04 3C 10 06 3C
       11 07 3D 05 08 3D
       06 07
 0902  3D 10 06 3D 11 0C      C 	 BYTE 3dh, 10h, 06h, 3dh, 11h, 0ch, 40h, 07h, 07h, 40h, 08h, 09h, 40h, 09h, 05h, 40h, 0fh, 07h, 40h, 10h
       40 07 07 40 08 09
       40 09 05 40 0F 07
       40 10
 0916  0B 41 06 08 41 07      C 	 BYTE 0bh, 41h, 06h, 08h, 41h, 07h, 0bh, 41h, 08h, 0dh, 41h, 09h, 0dh, 41h, 0ah, 01h, 41h, 0fh, 01h, 41h
       0B 41 08 0D 41 09
       0D 41 0A 01 41 0F
       01 41
 092A  10 01 41 11 0E 42      C 	 BYTE 10h, 01h, 41h, 11h, 0eh, 42h, 05h, 03h, 42h, 06h, 0eh, 42h, 07h, 0dh, 42h, 08h, 01h, 42h, 09h, 02h
       05 03 42 06 0E 42
       07 0D 42 08 01 42
       09 02
 093E  42 0A 09 42 0B 02      C 	 BYTE 42h, 0ah, 09h, 42h, 0bh, 02h, 42h, 10h, 05h, 42h, 11h, 05h, 43h, 05h, 0ch, 43h, 06h, 07h, 43h, 09h
       42 10 05 42 11 05
       43 05 0C 43 06 07
       43 09
 0952  09 43 0A 09 43 0B      C 	 BYTE 09h, 43h, 0ah, 09h, 43h, 0bh, 08h, 43h, 10h, 0ah, 43h, 11h, 09h, 44h, 05h, 08h, 44h, 06h, 0bh, 44h
       08 43 10 0A 43 11
       09 44 05 08 44 06
       0B 44
 0966  0A 09 44 0B 0A 44      C 	 BYTE 0ah, 09h, 44h, 0bh, 0ah, 44h, 0ch, 09h, 44h, 10h, 05h, 44h, 11h, 0ch, 45h, 05h, 0dh, 45h, 06h, 07h
       0C 09 44 10 05 44
       11 0C 45 05 0D 45
       06 07
 097A  45 0A 0B 45 0B 0B      C 	 BYTE 45h, 0ah, 0bh, 45h, 0bh, 0bh, 45h, 0ch, 01h, 45h, 0fh, 02h, 45h, 10h, 01h, 45h, 11h, 0ch, 46h, 05h
       45 0C 01 45 0F 02
       45 10 01 45 11 0C
       46 05
 098E  02 46 06 01 46 0B      C 	 BYTE 02h, 46h, 06h, 01h, 46h, 0bh, 05h, 46h, 0ch, 03h, 46h, 0dh, 03h, 46h, 0eh, 09h, 46h, 0fh, 08h, 46h
       05 46 0C 03 46 0D
       03 46 0E 09 46 0F
       08 46
 09A2  10 0A 46 11 07 47      C 	 BYTE 10h, 0ah, 46h, 11h, 07h, 47h, 06h, 0ah, 47h, 07h, 07h, 47h, 0bh, 02h, 47h, 0ch, 07h, 47h, 0dh, 0ch
       06 0A 47 07 07 47
       0B 02 47 0C 07 47
       0D 0C
 09B6  47 0E 0D 47 0F 08      C 	 BYTE 47h, 0eh, 0dh, 47h, 0fh, 08h, 47h, 10h, 0eh, 48h, 0ch, 0eh, 48h, 0dh, 08h, 48h, 0eh, 08h, 48h, 0fh
       47 10 0E 48 0C 0E
       48 0D 08 48 0E 08
       48 0F
 09CA  06		      C 	 BYTE 06h
 = 02BC			      C 	 memesSize EQU 02bch
			      C 
 09CB				 .code
				; ------------------------------------------------------------------

				clearBuff MACRO arg
				    push di
				    push cx
				    push ax
				    cld
				    mov di, offset arg
				    mov cx, sizeof arg						; Repeat for the length of the buffer
				    mov al, 0							; Clear with null (0)
				    rep stosb
				    pop di
				    pop cx
				    pop ax
				ENDM


 09CB				plotImage PROC
 09CB  B9 02BC			    mov cx, memesSize
 09CE  BE 0452 R		    mov si, offset memesImage
 09D1  33 C0			    xor ax, ax
 09D3  33 DB			    xor bx, bx
 09D5				  @@:
 09D5  8B 04			    mov ax, [si]
 09D7  46			    inc si
 09D8  8B 1C			    mov bx, [si]
 09DA  46			    inc si
 09DB  53			    push bx
 09DC  50			    push ax
 09DD  E8 0000 E		    call gotoxy
 09E0  58			    pop ax
 09E1  5B			    pop bx
 09E2  60			    pusha
 09E3  8A 1C			    mov bl, [si]
 09E5  B9 0001			    mov	cx, 1
 09E8  B7 00			    mov bh, 00 ; page | color
 09EA  B8 0920			    mov	ax, 0920h ; int | char
 09ED  CD 10			    int	    10h
 09EF  B8 0EDB			    mov ax, 0edbh  ; int | char
 09F2  CD 10			    int	    10h							; Video interupt
 09F4  61			    popa
 09F5  46			    inc si
 09F6  E2 DD			  loop @b

 09F8  C3			    ret
 09F9				plotImage ENDP
				; ------------------------------------------------------------------
				; int strcmp(const char *str1, const char *str2)
				; ------------------------------------------------------------------
				; Compares the string pointed to, by str1 to the string
				; pointed to by str2.

 09F9				strcmp PROC uses si di bx str1:WORD, str2:WORD
 09F9  55		   *	    push   bp
 09FA  8B EC		   *	    mov    bp, sp
 09FC  56		   *	    push   si
 09FD  57		   *	    push   di
 09FE  53		   *	    push   bx
 09FF  8B 7E 04			    mov di, str1						; Point to param address
 0A02  8B 76 06			    mov si, str2						; Point to param address

 0A05  33 C0			    xor ax, ax							; Char number total for SI
 0A07  33 DB			    xor bx, bx							; Char number total for DI

 0A09				  @@cmp:
 0A09  8A 04			    mov al, [si]						; Byte from SI
 0A0B  02 E0			    add ah, al							; Total ascii char number
 0A0D  8A 1D			    mov bl, [di]						; Byte from DI
 0A0F  02 FB			    add bh, bl							; Total ascii char number
 0A11  38 D8			    cmp al, bl
 0A13  75 08			    jne @@done
 0A15  3C 00			    cmp al, 0
 0A17  74 04			    je @@done
 0A19  47			    inc di
 0A1A  46			    inc si
 0A1B  EB EC			    jmp @@cmp

 0A1D				  @@done:
				    .IF bh == ah						; Return 0 if both str inputs equal
 0A1D  38 E7		   *	    cmp    bh, ah
 0A1F  75 05		   *	    jne    @C0001
 0A21  B8 0000				mov ax, 0
				    .ELSEIF bh > ah						; Return 1 if str1 is greater than str2
 0A24  EB 10		   *	    jmp    @C0003
 0A26			   *@C0001:
 0A26  38 E7		   *	    cmp    bh, ah
 0A28  76 05		   *	    jbe    @C0004
 0A2A  B8 0001				mov ax, 1
				    .ELSEIF bh < ah						; Return -1 if str1 is less than str2
 0A2D  EB 07		   *	    jmp    @C0006
 0A2F			   *@C0004:
 0A2F  38 E7		   *	    cmp    bh, ah
 0A31  73 03		   *	    jae    @C0007
 0A33  B8 FFFF				mov ax, -1
				    .ENDIF
 0A36			   *@C0007:
 0A36			   *@C0006:
 0A36			   *@C0003:

				    ret
 0A36  5B		   *	    pop    bx
 0A37  5F		   *	    pop    di
 0A38  5E		   *	    pop    si
 0A39  5D		   *	    pop    bp
 0A3A  C3		   *	    ret    00000h
 0A3B				strcmp ENDP


				; ------------------------------------------------------------------
				; int strncmp(const char *str1, const char *str2, size_t n)
				; ------------------------------------------------------------------
				; Compares at most the first n bytes of str1 and str2.

 0A3B				strncmp PROC uses si di bx cx str1:WORD, str2:WORD, n:PTR BYTE
 0A3B  55		   *	    push   bp
 0A3C  8B EC		   *	    mov    bp, sp
 0A3E  56		   *	    push   si
 0A3F  57		   *	    push   di
 0A40  53		   *	    push   bx
 0A41  51		   *	    push   cx
 0A42  8B 7E 04			    mov di, str1						; Point to param address str1
 0A45  8B 76 06			    mov si, str2						; Point to param address str2
 0A48  8B 4E 08			    mov cx, n							; Store n in cx for loop

 0A4B  33 C0			    xor ax, ax							; Char number total for SI
 0A4D  33 DB			    xor bx, bx							; Char number total for DI

				    .REPEAT
 0A4F			   *@C0009:
 0A4F  8A 04				mov al, [si]						; Byte from S
 0A51  02 E0				add ah, al
 0A53  8A 1D				mov bl, [di]						; Byte from DI
 0A55  02 FB				add bh, bl
					.IF al != bl						; Both bytes equal before null?
 0A57  38 D8		   *	    cmp    al, bl
 0A59  74 04		   *	    je     @C000A
					    .BREAK
 0A5B  EB 0D		   *	    jmp    @C000D
					.ELSEIF !al
 0A5D  EB 06		   *	    jmp    @C000E
 0A5F			   *@C000A:
 0A5F  0A C0		   *	    or	al, al
 0A61  75 02		   *	    jne    @C000F
					    .BREAK
 0A63  EB 05		   *	    jmp    @C000D
					.ENDIF
 0A65			   *@C000F:
 0A65			   *@C000E:
 0A65  47				inc di
 0A66  46				inc si
 0A67  49				dec cx
				    .UNTILCXZ
 0A68  E2 E5		   *	    loop   @C0009
 0A6A			   *@C000D:

				    .IF bh == ah						; Return 0 if both str inputs equal
 0A6A  38 E7		   *	    cmp    bh, ah
 0A6C  75 05		   *	    jne    @C0011
 0A6E  B8 0000				mov ax, 0
				    .ELSEIF bh > ah						; Return 1 if str1 is greater than str2
 0A71  EB 0E		   *	    jmp    @C0013
 0A73			   *@C0011:
 0A73  38 E7		   *	    cmp    bh, ah
 0A75  76 04		   *	    jbe    @C0014
 0A77  B4 01				mov ah, 1
				    .ELSEIF bh < ah						; Return -1 if str1 is less than str2
 0A79  EB 06		   *	    jmp    @C0016
 0A7B			   *@C0014:
 0A7B  38 E7		   *	    cmp    bh, ah
 0A7D  73 02		   *	    jae    @C0017
 0A7F  B4 FF				mov ah, -1
				    .ENDIF
 0A81			   *@C0017:
 0A81			   *@C0016:
 0A81			   *@C0013:

				    ret
 0A81  59		   *	    pop    cx
 0A82  5B		   *	    pop    bx
 0A83  5F		   *	    pop    di
 0A84  5E		   *	    pop    si
 0A85  5D		   *	    pop    bp
 0A86  C3		   *	    ret    00000h
 0A87				strncmp ENDP


				; ------------------------------------------------------------------
				; int strcoll(const char *str1, const char *str2)
				; ------------------------------------------------------------------
				; Compares the string pointed to, by str1 to the string
				; pointed to by str2.

 0A87				strcoll PROC uses si di bx str1:WORD, str2:WORD
 0A87  55		   *	    push   bp
 0A88  8B EC		   *	    mov    bp, sp
 0A8A  56		   *	    push   si
 0A8B  57		   *	    push   di
 0A8C  53		   *	    push   bx
 0A8D  8B 7E 04			    mov di, str1						; Point to str1
 0A90  8B 76 06			    mov si, str2						; Point to str2

 0A93  33 C0			    xor ax, ax							; Char number total for SI
 0A95  33 DB			    xor bx, bx							; Char number total for DI

				   .REPEAT
 0A97			   *@C0019:
 0A97  8A 04				mov al, [si]						; Byte from SI
 0A99  02 E0				add ah, al						; Total ascii char number
 0A9B  8A 1D				mov bl, [di]						; Byte from DI
 0A9D  02 FB				add bh, bl						; Total ascii char number
					.IF al != bl						; Both bytes equal before null?
 0A9F  38 D8		   *	    cmp    al, bl
 0AA1  74 04		   *	    je     @C001A
					    .BREAK
 0AA3  EB 0C		   *	    jmp    @C001D
					.ELSEIF !al
 0AA5  EB 06		   *	    jmp    @C001E
 0AA7			   *@C001A:
 0AA7  0A C0		   *	    or	al, al
 0AA9  75 02		   *	    jne    @C001F
					    .BREAK
 0AAB  EB 04		   *	    jmp    @C001D
					.ENDIF
 0AAD			   *@C001F:
 0AAD			   *@C001E:
 0AAD  47				inc di
 0AAE  46				inc si
				    .UNTIL 0
 0AAF  EB E6		   *	    jmp    @C0019
 0AB1			   *@C001D:

				    .IF bh == ah						; Return 0 if both str inputs equal
 0AB1  38 E7		   *	    cmp    bh, ah
 0AB3  75 05		   *	    jne    @C0022
 0AB5  B8 0000			    	mov ax, 0
				    .ELSEIF bh > ah						; Return 1 if str1 is greater than str2
 0AB8  EB 0E		   *	    jmp    @C0024
 0ABA			   *@C0022:
 0ABA  38 E7		   *	    cmp    bh, ah
 0ABC  76 04		   *	    jbe    @C0025
 0ABE  B4 01			    	mov ah, 1
				    .ELSEIF bh < ah						; Return -1 if str1 is less than str2
 0AC0  EB 06		   *	    jmp    @C0027
 0AC2			   *@C0025:
 0AC2  38 E7		   *	    cmp    bh, ah
 0AC4  73 02		   *	    jae    @C0028
 0AC6  B4 FF			    	mov ah, -1
				    .ENDIF
 0AC8			   *@C0028:
 0AC8			   *@C0027:
 0AC8			   *@C0024:

				    ret
 0AC8  5B		   *	    pop    bx
 0AC9  5F		   *	    pop    di
 0ACA  5E		   *	    pop    si
 0ACB  5D		   *	    pop    bp
 0ACC  C3		   *	    ret    00000h
 0ACD				strcoll ENDP


				; ------------------------------------------------------------------
				; char *strcpy(char *dest, const char *src)
				; ------------------------------------------------------------------
				; Coppy string in src to dest

 0ACD				strcpy PROC uses si di ax bx dest:WORD, src:WORD
 0ACD  55		   *	    push   bp
 0ACE  8B EC		   *	    mov    bp, sp
 0AD0  56		   *	    push   si
 0AD1  57		   *	    push   di
 0AD2  50		   *	    push   ax
 0AD3  53		   *	    push   bx
 0AD4  8B 7E 04			    mov di, dest						; Point to dest address
 0AD7  8B 76 06			    mov si, src							; Point to src address

 0ADA				  @@cpy:
 0ADA  AC			    lodsb
 0ADB  AA			    stosb							; Transfer contents
 0ADC  0A C0			    or al, al							; If source string is empty, quit out
 0ADE  75 FA			    jne @@cpy

				    ret
 0AE0  5B		   *	    pop    bx
 0AE1  58		   *	    pop    ax
 0AE2  5F		   *	    pop    di
 0AE3  5E		   *	    pop    si
 0AE4  5D		   *	    pop    bp
 0AE5  C3		   *	    ret    00000h
 0AE6				strcpy ENDP


				; ------------------------------------------------------------------
				; char *strncpy(char *dest, const char *src, size_t n)
				; ------------------------------------------------------------------
				; Coppy string in src to dest up to n chars.

 0AE6				strncpy PROC uses si di ax bx dest:WORD, src:WORD, n:PTR BYTE
 0AE6  55		   *	    push   bp
 0AE7  8B EC		   *	    mov    bp, sp
 0AE9  56		   *	    push   si
 0AEA  57		   *	    push   di
 0AEB  50		   *	    push   ax
 0AEC  53		   *	    push   bx
 0AED  8B 7E 04			    mov di, dest						; Point to dest address
 0AF0  8B 76 06			    mov si, src							; Point to src address
 0AF3  8B 4E 08			    mov cx, n							; Times to iterate

 0AF6				  @@cpy:
 0AF6  AC			    lodsb
 0AF7  AA			    stosb							; Transfer contents
 0AF8  0A C0			    or al, al							; If source string is empty, quit out
 0AFA  74 02			    jz @@done
 0AFC  E2 F8			    loop @@cpy

 0AFE				  @@done:
				    ret
 0AFE  5B		   *	    pop    bx
 0AFF  58		   *	    pop    ax
 0B00  5F		   *	    pop    di
 0B01  5E		   *	    pop    si
 0B02  5D		   *	    pop    bp
 0B03  C3		   *	    ret    00000h
 0B04				strncpy ENDP


				; ------------------------------------------------------------------
				; size_t strlen(const char *str)
				; ------------------------------------------------------------------
				; Get the length of the string.

 0B04				strlen PROC uses si cx string:WORD
 0B04  55		   *	    push   bp
 0B05  8B EC		   *	    mov    bp, sp
 0B07  56		   *	    push   si
 0B08  51		   *	    push   cx
 0B09  8B 76 04			    mov si, string						; Point to string address

 0B0C  33 C9			    xor cx, cx							; Store n in cx for loop

 0B0E				  @@loop:
 0B0E  AC			    lodsb							; Get character from string
 0B0F  0A C0			    or al, al							; End of string
 0B11  74 03			    jz @@done
 0B13  41			    inc cx
 0B14  EB F8			    jmp @@loop

 0B16				  @@done:
 0B16  8B C1			    mov ax, cx							; Return the length of the string

				    ret
 0B18  59		   *	    pop    cx
 0B19  5E		   *	    pop    si
 0B1A  5D		   *	    pop    bp
 0B1B  C3		   *	    ret    00000h
 0B1C				strlen ENDP


				; ------------------------------------------------------------------
				; char *strchr(const char *str, int n)
				; ------------------------------------------------------------------
				; Searches for the first occurrence of the character c
				; (an unsigned char) in the string pointed to, by the
				; argument str.

 0B1C				strchr PROC uses si di cx string:WORD, n:BYTE
				    clearBuff return_buffer
 0B1C  55		   *	    push   bp
 0B1D  8B EC		   *	    mov    bp, sp
 0B1F  56		   *	    push   si
 0B20  57		   *	    push   di
 0B21  51		   *	    push   cx
 0B22  57		     1	    push di
 0B23  51		     1	    push cx
 0B24  50		     1	    push ax
 0B25  FC		     1	    cld
 0B26  BF 0000 R	     1	    mov di, offset return_buffer
 0B29  B9 0040		     1	    mov cx, sizeof return_buffer						; Repeat for the length of the buffer
 0B2C  B0 00		     1	    mov al, 0							; Clear with null (0)
 0B2E  F3/ AA		     1	    rep stosb
 0B30  5F		     1	    pop di
 0B31  59		     1	    pop cx
 0B32  58		     1	    pop ax

 0B33  8B 76 04			    mov si, string						; Point to param address str1
 0B36  BF 0000 R		    mov di, offset return_buffer				; Point to param ret str1
 0B39  8A 4E 06			    mov cl, n

 0B3C				  @@loop:
 0B3C  AC			    lodsb							; Get character from string
 0B3D  0A C0			    or al, al							; End of string
 0B3F  74 0D			    jz @@done
 0B41  38 C8			    cmp al, cl
 0B43  75 F7			    jne @@loop
 0B45  AA			    stosb

 0B46				  @@found:
 0B46  AC			    lodsb							; Get character from string
 0B47  0A C0			    or al, al							; End of string
 0B49  74 03			    jz @@done
 0B4B  AA			    stosb
 0B4C  EB F8			    jmp @@found

 0B4E				  @@done:
 0B4E  B8 0000 R		    mov ax, offset return_buffer

				    ret
 0B51  59		   *	    pop    cx
 0B52  5F		   *	    pop    di
 0B53  5E		   *	    pop    si
 0B54  5D		   *	    pop    bp
 0B55  C3		   *	    ret    00000h
 0B56				strchr ENDP


				; ------------------------------------------------------------------
				; char *strcat(char *dest, const char *src)
				; ------------------------------------------------------------------
				; The strcat function concatenates or appends src to dest.
				; All characters from src are copied including the
				; terminating null character.

 0B56				strcat PROC uses si di ax dest:WORD, src:WORD
 0B56  55		   *	    push   bp
 0B57  8B EC		   *	    mov    bp, sp
 0B59  56		   *	    push   si
 0B5A  57		   *	    push   di
 0B5B  50		   *	    push   ax
 0B5C  8B 7E 04			    mov di, dest					    ; Point to dest address
 0B5F  8B 76 06			    mov si, src						    ; Point to source address

 0B62				  @@inc:						    ; Find the end of the dest string
 0B62  47			    inc di
 0B63  8A 05			    mov al, [di]
 0B65  0A C0			    or al, al
 0B67  75 F9			    jnz @@inc

 0B69				  @@append:
 0B69  8A 04			    mov al, [si]					    ; Transfer contents of source to dest
 0B6B  88 05			    mov [di], al
 0B6D  46			    inc si
 0B6E  47			    inc di
 0B6F  0A C0			    or al, al
 0B71  75 F6			    jne @@append

				    ret
 0B73  58		   *	    pop    ax
 0B74  5F		   *	    pop    di
 0B75  5E		   *	    pop    si
 0B76  5D		   *	    pop    bp
 0B77  C3		   *	    ret    00000h
 0B78				strcat ENDP


				; ------------------------------------------------------------------
				; char *strncat(char *dest, const char *src, size_t n)
				; ------------------------------------------------------------------
				; The strncat function concatenates or appends first n characters
				; from src to dest. All characters from src are copied including
				; the terminating null character.

 0B78				strncat PROC uses si di ax dest:WORD, src:WORD, n:PTR BYTE
 0B78  55		   *	    push   bp
 0B79  8B EC		   *	    mov    bp, sp
 0B7B  56		   *	    push   si
 0B7C  57		   *	    push   di
 0B7D  50		   *	    push   ax
 0B7E  8B 7E 04			    mov di, dest					    ; Point to dest address
 0B81  8B 76 06			    mov si, src						    ; Point to source address
 0B84  8B 4E 08			    mov cx, n						    ; Point to n address

 0B87				  @@inc:						    ; Find the end of the dest
 0B87  47			    inc di
 0B88  8A 05			    mov al, [di]
 0B8A  0A C0			    or al, al
 0B8C  75 F9			    jnz @@inc

 0B8E				  @@append:
 0B8E  8A 04			    mov al, [si]					    ; Transfer contents of source to dest up to n
 0B90  88 05			    mov [di], al
 0B92  46			    inc si
 0B93  47			    inc di
 0B94  E2 F8			    loop @@append

				    ret
 0B96  58		   *	    pop    ax
 0B97  5F		   *	    pop    di
 0B98  5E		   *	    pop    si
 0B99  5D		   *	    pop    bp
 0B9A  C3		   *	    ret    00000h
 0B9B				strncat ENDP


				; ------------------------------------------------------------------
				; void *memset(void *str, int c, size_t n)
				; ------------------------------------------------------------------
				; Copies the character c (an unsigned char) to the first n
				; characters of the string pointed to, by the argument str.

 0B9B				memset PROC uses si di ax cx string:WORD, char:BYTE, n:PTR BYTE
 0B9B  55		   *	    push   bp
 0B9C  8B EC		   *	    mov    bp, sp
 0B9E  56		   *	    push   si
 0B9F  57		   *	    push   di
 0BA0  50		   *	    push   ax
 0BA1  51		   *	    push   cx
 0BA2  8B 7E 04			    mov di, string					    ; Point to str address
 0BA5  8B 4E 08			    mov cx, n						    ; Point to n address

 0BA8				  @@append:
 0BA8  8A 46 06			    mov al, char					    ; Move c into str n times
 0BAB  88 05			    mov [di], al
 0BAD  47			    inc di
 0BAE  E2 F8			    loop @@append

				    ret
 0BB0  59		   *	    pop    cx
 0BB1  58		   *	    pop    ax
 0BB2  5F		   *	    pop    di
 0BB3  5E		   *	    pop    si
 0BB4  5D		   *	    pop    bp
 0BB5  C3		   *	    ret    00000h
 0BB6				memset ENDP


				; ------------------------------------------------------------------
				; void *memmove(void *dest, const void *src, size_t n)
				; ------------------------------------------------------------------
				; Copies n characters from src to dest.

 0BB6				memmove PROC uses si di ax cx dest:WORD, src:WORD, n:PTR BYTE
 0BB6  55		   *	    push   bp
 0BB7  8B EC		   *	    mov    bp, sp
 0BB9  56		   *	    push   si
 0BBA  57		   *	    push   di
 0BBB  50		   *	    push   ax
 0BBC  51		   *	    push   cx
 0BBD  8B 7E 04			    mov di, dest						; Point to dest address
 0BC0  8B 76 06			    mov si, src							; Point to src address
 0BC3  8B 4E 08			    mov cx, n							; Point to n address

 0BC6				  @@append:
 0BC6  8A 04			    mov al, [si]						; Char from src to al
 0BC8  88 05			    mov [di], al						; Char from al moves into dest
 0BCA  47			    inc di
 0BCB  46			    inc si
 0BCC  E2 F8			    loop @@append

				    ret
 0BCE  59		   *	    pop    cx
 0BCF  58		   *	    pop    ax
 0BD0  5F		   *	    pop    di
 0BD1  5E		   *	    pop    si
 0BD2  5D		   *	    pop    bp
 0BD3  C3		   *	    ret    00000h
 0BD4				memmove ENDP


				; ------------------------------------------------------------------
				; void *memcpy(void *dest, const void *src, size_t n)
				; ------------------------------------------------------------------
				; This function copies n characters from memory at src to the
				; memory area at the dest.

 0BD4				memcpy PROC uses si di ax cx dest:WORD, src:WORD, n:PTR BYTE
 0BD4  55		   *	    push   bp
 0BD5  8B EC		   *	    mov    bp, sp
 0BD7  56		   *	    push   si
 0BD8  57		   *	    push   di
 0BD9  50		   *	    push   ax
 0BDA  51		   *	    push   cx
 0BDB  8B 7E 04			    mov di, dest					    ; Point to str1 address
 0BDE  8B 76 06			    mov si, src						    ; Point to str2 address
 0BE1  8B 4E 08			    mov cx, n						    ; Point to n address

 0BE4				  @@cpy:
 0BE4  8A 04			    mov al, [si]					    ; Transfer contents (at least one byte terminator)
 0BE6  88 05			    mov [di], al
 0BE8  0A C0			    or al, al
 0BEA  74 05			    je @@done
 0BEC  46			    inc si
 0BED  47			    inc di
 0BEE  41			    inc cx
 0BEF  E2 F3			    loop @@cpy

 0BF1				  @@done:
				    ret
 0BF1  59		   *	    pop    cx
 0BF2  58		   *	    pop    ax
 0BF3  5F		   *	    pop    di
 0BF4  5E		   *	    pop    si
 0BF5  5D		   *	    pop    bp
 0BF6  C3		   *	    ret    00000h
 0BF7				memcpy ENDP


				; ------------------------------------------------------------------
				; int memcmp(const void *str1, const void *str2, size_t n)
				; ------------------------------------------------------------------
				; Compares at most the first n bytes of str1 and str2.

 0BF7				memcmp PROC uses si di bx cx str1:WORD, str2:WORD, n:PTR BYTE
 0BF7  55		   *	    push   bp
 0BF8  8B EC		   *	    mov    bp, sp
 0BFA  56		   *	    push   si
 0BFB  57		   *	    push   di
 0BFC  53		   *	    push   bx
 0BFD  51		   *	    push   cx
 0BFE  8B 7E 04			    mov di, str1						; Point to str1 address
 0C01  8B 76 06			    mov si, str2						; Point to str2 address
 0C04  8B 4E 08			    mov cx, n							; Point to n addres

 0C07  33 C0			    xor ax, ax							; Char number total for SI
 0C09  33 DB			    xor bx, bx							; Char number total for DI

 0C0B				  @@cmp:
 0C0B  8A 04			    mov al, [si]						; Byte from S
 0C0D  02 E0			    add ah, al							; Add byte value to ah
 0C0F  8A 1D			    mov bl, [di]						; Byte from DI
 0C11  02 FB			    add bh, bl							; Add byte value to bh
 0C13  38 D8			    cmp al, bl							; If both bytes not equal then exit
 0C15  75 08			    jne @@done
 0C17  0A C0			    or al, al							; If no bytes left then exit
 0C19  74 04			    jz @@done
 0C1B  47			    inc di
 0C1C  46			    inc si
 0C1D  E2 EC			    loop @@cmp

 0C1F				  @@done:
				    .IF bh == ah						; Return 0 if both str inputs equal
 0C1F  38 E7		   *	    cmp    bh, ah
 0C21  75 05		   *	    jne    @C002A
 0C23  B8 0000			    	mov ax, 0
				    .ELSEIF bh > ah						; Return 1 if str1 is greater than str2
 0C26  EB 0E		   *	    jmp    @C002C
 0C28			   *@C002A:
 0C28  38 E7		   *	    cmp    bh, ah
 0C2A  76 04		   *	    jbe    @C002D
 0C2C  B4 01			    	mov ah, 1
				    .ELSEIF bh < ah						; Return -1 if str1 is less than str2
 0C2E  EB 06		   *	    jmp    @C002F
 0C30			   *@C002D:
 0C30  38 E7		   *	    cmp    bh, ah
 0C32  73 02		   *	    jae    @C0030
 0C34  B4 FF			    	mov ah, -1
				    .ENDIF
 0C36			   *@C0030:
 0C36			   *@C002F:
 0C36			   *@C002C:

				    ret
 0C36  59		   *	    pop    cx
 0C37  5B		   *	    pop    bx
 0C38  5F		   *	    pop    di
 0C39  5E		   *	    pop    si
 0C3A  5D		   *	    pop    bp
 0C3B  C3		   *	    ret    00000h
 0C3C				memcmp ENDP


				; ------------------------------------------------------------------
				; void *memchr(const void *str, int c, size_t n)
				; ------------------------------------------------------------------
				; Searches for the first occurrence of the character c
				; (an unsigned char) in the first n bytes of the string
				; pointed to, by the argument str.

 0C3C				memchr PROC uses si di bx cx string:WORD, char:BYTE, n:PTR BYTE
				    clearBuff return_buffer
 0C3C  55		   *	    push   bp
 0C3D  8B EC		   *	    mov    bp, sp
 0C3F  56		   *	    push   si
 0C40  57		   *	    push   di
 0C41  53		   *	    push   bx
 0C42  51		   *	    push   cx
 0C43  57		     1	    push di
 0C44  51		     1	    push cx
 0C45  50		     1	    push ax
 0C46  FC		     1	    cld
 0C47  BF 0000 R	     1	    mov di, offset return_buffer
 0C4A  B9 0040		     1	    mov cx, sizeof return_buffer						; Repeat for the length of the buffer
 0C4D  B0 00		     1	    mov al, 0							; Clear with null (0)
 0C4F  F3/ AA		     1	    rep stosb
 0C51  5F		     1	    pop di
 0C52  59		     1	    pop cx
 0C53  58		     1	    pop ax

 0C54  8B 76 04			    mov si, string						; Point to param address str
 0C57  BF 0000 R		    mov di, offset return_buffer

 0C5A				  @@loop:
 0C5A  AC			    lodsb							; Get character from string
 0C5B  0A C0			    or al, al							; End of string
 0C5D  74 19			    jz @@done
 0C5F  3A 46 06			    cmp al, char
 0C62  75 F6			    jne @@loop

 0C64  88 05			    mov [di], al						; Add n to buffer and increase
 0C66  47			    inc di

 0C67  8B 4E 08			    mov cx, n						; Times to iterate
 0C6A  0B C9			    or cx, cx
 0C6C  74 0A			    jz @@done

 0C6E				  @@iterate:
 0C6E  AC			    lodsb							; Get character from string
 0C6F  0A C0			    or al, al							; End of string
 0C71  74 05			    jz @@done
 0C73  88 05			    mov [di], al
 0C75  47			    inc di
 0C76  E2 F6			    loop @@iterate

 0C78				  @@done:
 0C78  B8 0000 R		    mov ax, offset return_buffer

				    ret
 0C7B  59		   *	    pop    cx
 0C7C  5B		   *	    pop    bx
 0C7D  5F		   *	    pop    di
 0C7E  5E		   *	    pop    si
 0C7F  5D		   *	    pop    bp
 0C80  C3		   *	    ret    00000h
 0C81				memchr ENDP


				; ------------------------------------------------------------------
				; size_t strcspn(const char *str1, const char *str2);
				; ------------------------------------------------------------------
				; This function calculates the length of the initial
				; segment of str1, which consists entirely of characters
				; not in str2.

 0C81				strcspn PROC uses si di bx cx str1:WORD, str2:WORD
 0C81  55		   *	    push   bp
 0C82  8B EC		   *	    mov    bp, sp
 0C84  56		   *	    push   si
 0C85  57		   *	    push   di
 0C86  53		   *	    push   bx
 0C87  51		   *	    push   cx
 0C88  8B 76 04			    mov si, str1					    ; Point to str1 address
 0C8B  8B 7E 06			    mov di, str2					    ; Point to str2 address

 0C8E  33 C9			    xor cx, cx

 0C90				  @@cmp:
 0C90  8A 04			    mov al, [si]					    ; Byte from SI
 0C92  57			    push di						    ; Save DI

 0C93				  @@char:
 0C93  8A 1D			    mov bl, [di]					    ; Byte from DI
 0C95  38 D8			    cmp al, bl						    ; If both bytes equal then exit
 0C97  74 0E			    je @@exit
 0C99  47			    inc di						    ; Increase DI untill zero
 0C9A  0A DB			    or bl, bl
 0C9C  75 F5			    jnz @@char
 0C9E  5F			    pop di						    ; Restore DI
 0C9F  0A C0			    or al, al						    ; If no bytes left then exit
 0CA1  74 05			    jz @@done
 0CA3  46			    inc si
 0CA4  41			    inc cx
 0CA5  EB E9			    jmp @@cmp

 0CA7				  @@exit:
 0CA7  5F			     pop di						    ; Restore DI

 0CA8				  @@done:
 0CA8  8B C1			    mov ax, cx
				    ret
 0CAA  59		   *	    pop    cx
 0CAB  5B		   *	    pop    bx
 0CAC  5F		   *	    pop    di
 0CAD  5E		   *	    pop    si
 0CAE  5D		   *	    pop    bp
 0CAF  C3		   *	    ret    00000h
 0CB0				strcspn ENDP


				; ------------------------------------------------------------------
				; char *strpbrk(const char *str1, const char *str2);
				; ------------------------------------------------------------------
				; This function finds the first character in the string str1
				; that matches any character specified in str2. This does
				; not include the terminating null-characters.

 0CB0				strpbrk PROC uses si di bx str1:WORD, str2:WORD
				    clearBuff return_buffer
 0CB0  55		   *	    push   bp
 0CB1  8B EC		   *	    mov    bp, sp
 0CB3  56		   *	    push   si
 0CB4  57		   *	    push   di
 0CB5  53		   *	    push   bx
 0CB6  57		     1	    push di
 0CB7  51		     1	    push cx
 0CB8  50		     1	    push ax
 0CB9  FC		     1	    cld
 0CBA  BF 0000 R	     1	    mov di, offset return_buffer
 0CBD  B9 0040		     1	    mov cx, sizeof return_buffer						; Repeat for the length of the buffer
 0CC0  B0 00		     1	    mov al, 0							; Clear with null (0)
 0CC2  F3/ AA		     1	    rep stosb
 0CC4  5F		     1	    pop di
 0CC5  59		     1	    pop cx
 0CC6  58		     1	    pop ax

 0CC7  8B 76 04			    mov si, str1						; Point to str1 address
 0CCA  8B 7E 06			    mov di, str2						; Point to str2 address

 0CCD				  @@cmp:
 0CCD  8A 04			    mov al, [si]						; Byte from SI
 0CCF  57			    push di							; Save DI

 0CD0				  @@char:
 0CD0  8A 1D			    mov bl, [di]						; Byte from DI
 0CD2  38 D8			    cmp al, bl							; If both bytes equal then exit
 0CD4  74 0D			    je @@equal
 0CD6  47			    inc di							; Increase DI untill zero
 0CD7  0A DB			    or bl, bl
 0CD9  75 F5			    jnz @@char
 0CDB  5F			    pop di							; Restore DI

 0CDC  0A C0			    or al, al							; If no bytes left then exit
 0CDE  74 18			    jz @@error
 0CE0  46			    inc si
 0CE1  EB EA			    jmp @@cmp

 0CE3				  @@equal:
 0CE3  5F			    pop di
 0CE4  BF 0000 R		    mov di, offset return_buffer				; Found equal char

 0CE7				  @@fill:
 0CE7  8A 04			    mov al, [si]
 0CE9  88 05			    mov [di], al
 0CEB  0A C0			    or al, al							; If no bytes left then exit
 0CED  74 04			    jz @@buff
 0CEF  46			    inc si
 0CF0  47			    inc di
 0CF1  EB F4			    jmp @@fill

 0CF3				  @@buff:
 0CF3  B8 0000 R		    mov ax, offset return_buffer
 0CF6  EB 03			    jmp @@done

 0CF8				  @@error:
 0CF8  B8 0000			    mov ax, 0							 ; Return null on char not found

 0CFB				  @@done:
				    ret
 0CFB  5B		   *	    pop    bx
 0CFC  5F		   *	    pop    di
 0CFD  5E		   *	    pop    si
 0CFE  5D		   *	    pop    bp
 0CFF  C3		   *	    ret    00000h
 0D00				strpbrk ENDP


				; ------------------------------------------------------------------
				; char *strrchr(const char *str, int n);
				; ------------------------------------------------------------------
				; This function searches for the last occurrence of the
				; character c (an unsigned char) in the string pointed
				; to, by the argument str.

 0D00				strrchr PROC uses si di bx cx str1:WORD, n:BYTE
				    clearBuff return_buffer
 0D00  55		   *	    push   bp
 0D01  8B EC		   *	    mov    bp, sp
 0D03  56		   *	    push   si
 0D04  57		   *	    push   di
 0D05  53		   *	    push   bx
 0D06  51		   *	    push   cx
 0D07  57		     1	    push di
 0D08  51		     1	    push cx
 0D09  50		     1	    push ax
 0D0A  FC		     1	    cld
 0D0B  BF 0000 R	     1	    mov di, offset return_buffer
 0D0E  B9 0040		     1	    mov cx, sizeof return_buffer						; Repeat for the length of the buffer
 0D11  B0 00		     1	    mov al, 0							; Clear with null (0)
 0D13  F3/ AA		     1	    rep stosb
 0D15  5F		     1	    pop di
 0D16  59		     1	    pop cx
 0D17  58		     1	    pop ax

 0D18  8B 76 04			    mov si, str1						; Point to str1 address
 0D1B  56			    push si							; Save SI

 0D1C  33 C9			    xor cx, cx							; Clear counter
 0D1E  33 DB			    xor bx, bx							; Clear counter storage

 0D20				  @@cmp:
 0D20  8A 04			    mov al, [si]						; Byte from SI
 0D22  3A 46 06			    cmp al, n
 0D25  74 02			    je @@found							; If equal store counter in BX
 0D27  75 02			    jne @@cont							; Else continue

 0D29				  @@found:
 0D29  8B D9			    mov bx, cx

 0D2B				  @@cont:
 0D2B  0A C0			    or al, al
 0D2D  74 04			    jz @@fill							; If no more bytes left we need to now fill the buffer
 0D2F  46			    inc si							; Increment string
 0D30  41			    inc cx							; Increment counter
 0D31  EB ED			    jmp @@cmp

 0D33				  @@fill:
 0D33  5E			    pop si							; Restore the string
 0D34  0B DB			    or bx, bx							; If stored counter is null return null
 0D36  74 0F			    jz @@error
 0D38  03 F3			    add si, bx							; Add offfset of counter and string
 0D3A  BF 0000 R		    mov di, offset return_buffer				; Point DI to the offset of return_buffer

 0D3D				  @@iterate:
 0D3D  AC			    lodsb							; Get character from string
 0D3E  0A C0			    or al, al							; End of string
 0D40  74 09			    jz @@finished
 0D42  88 05			    mov [di], al						; Store char into DI
 0D44  47			    inc di							; Increase DI
 0D45  EB F6			    jmp @@iterate

 0D47				  @@error:
 0D47  33 C0			    xor ax, ax
 0D49  EB 03			    jmp @@done

 0D4B				  @@finished:
 0D4B  B8 0000 R		    mov ax, offset return_buffer

 0D4E				  @@done:
				    ret
 0D4E  59		   *	    pop    cx
 0D4F  5B		   *	    pop    bx
 0D50  5F		   *	    pop    di
 0D51  5E		   *	    pop    si
 0D52  5D		   *	    pop    bp
 0D53  C3		   *	    ret    00000h
 0D54				strrchr ENDP


				; ------------------------------------------------------------------
				; size_t strspn(const char *str1, const char *str2);
				; ------------------------------------------------------------------
				; This function calculates the length of the initial
				; segment of str1 which consists entirely of chars
				; in str2.

 0D54				strspn PROC uses di si cx str1:PTR WORD, str2:WORD
 0D54  55		   *	    push   bp
 0D55  8B EC		   *	    mov    bp, sp
 0D57  57		   *	    push   di
 0D58  56		   *	    push   si
 0D59  51		   *	    push   cx
 0D5A  8B 76 04			    mov si, str1						; Point to str1 address
 0D5D  8B 7E 06			    mov di, str2						; Point to str2 address

 0D60  33 C9			    xor cx, cx							; Clear counter

 0D62				  @@cmp:
 0D62  8A 04			    mov al, [si]						; Byte from S
 0D64  8A 1D			    mov bl, [di]						; Byte from DI
 0D66  38 D8			    cmp al, bl							; If both bytes not equal then exit
 0D68  75 09			    jne @@done
 0D6A  0A C0			    or al, al							; If no bytes left then exit
 0D6C  74 05			    jz @@done
 0D6E  47			    inc di
 0D6F  46			    inc si
 0D70  41			    inc cx
 0D71  EB EF			    jmp @@cmp

 0D73				  @@done:
 0D73  8B C1			    mov ax, cx							; Return counter number
				    ret
 0D75  59		   *	    pop    cx
 0D76  5E		   *	    pop    si
 0D77  5F		   *	    pop    di
 0D78  5D		   *	    pop    bp
 0D79  C3		   *	    ret    00000h
 0D7A				strspn ENDP


				; ------------------------------------------------------------------
				; char *strstr(const char *haystack, const char *needle)
				; ------------------------------------------------------------------
				; This function finds the first occurrence of the substring
				; needle in the string haystack. The terminating '\0'
				; characters are not compared.

 0D7A				strstr PROC uses si di bx cx haystack:WORD, needle:WORD
				    clearBuff return_buffer
 0D7A  55		   *	    push   bp
 0D7B  8B EC		   *	    mov    bp, sp
 0D7D  56		   *	    push   si
 0D7E  57		   *	    push   di
 0D7F  53		   *	    push   bx
 0D80  51		   *	    push   cx
 0D81  57		     1	    push di
 0D82  51		     1	    push cx
 0D83  50		     1	    push ax
 0D84  FC		     1	    cld
 0D85  BF 0000 R	     1	    mov di, offset return_buffer
 0D88  B9 0040		     1	    mov cx, sizeof return_buffer						; Repeat for the length of the buffer
 0D8B  B0 00		     1	    mov al, 0							; Clear with null (0)
 0D8D  F3/ AA		     1	    rep stosb
 0D8F  5F		     1	    pop di
 0D90  59		     1	    pop cx
 0D91  58		     1	    pop ax

 0D92  8B 76 04			    mov si, haystack						; Point to haystack address
 0D95  8B 7E 06			    mov di, needle						; Point to needle address

 0D98  33 C9			    xor cx, cx							; Store n in cx for loop

 0D9A				  @@cmp:
 0D9A  8A 04			    mov al, [si]						; Byte from SI
 0D9C  8A 1D			    mov bl, [di]						; Byte from DI
 0D9E  38 D8			    cmp al, bl							; If not equal continue to iterate
 0DA0  75 12			    jne @@cont
 0DA2  60			    pusha

 0DA3				  @@cmpstr:
 0DA3  8A 04			    mov al, [si]						; Byte from SI
 0DA5  8A 1D			    mov bl, [di]						; Byte from DI
 0DA7  0A DB			    or bl, bl							; If end of needle return true
 0DA9  74 11			    je @@equal
 0DAB  38 D8			    cmp al, bl							; Test if equal
 0DAD  75 04			    jne @@notequal						; If not equal continue @@cmp loop
 0DAF  47			    inc di
 0DB0  46			    inc si
 0DB1  EB F0			    jmp @@cmpstr

 0DB3				  @@notequal:
 0DB3  61			    popa

 0DB4				  @@cont:
 0DB4  0A C0			    or al, al							; If no bytes left then exit
 0DB6  74 17			    jz @@done
 0DB8  46			    inc si
 0DB9  41			    inc cx
 0DBA  EB DE			    jmp @@cmp

 0DBC				 @@equal:
 0DBC  61			    popa
 0DBD  BF 0000 R		    mov di, offset return_buffer				; Point DI to the offset of return_buffer
 0DC0  8B 76 04			    mov si, haystack						; Point to haystack address
 0DC3  03 F1			    add si, cx

 0DC5				 @@iterate:
 0DC5  AC			   lodsb							; Get character from string
 0DC6  0A C0			   or al, al							; End of string
 0DC8  74 05			   jz @@done
 0DCA  88 05			   mov [di], al							; Store char into DI
 0DCC  47			   inc di							; Increase DI
 0DCD  EB F6			   jmp @@iterate

 0DCF				  @@done:
 0DCF  B8 0000 R		    mov ax, offset return_buffer				; Return the buffer
				    ret
 0DD2  59		   *	    pop    cx
 0DD3  5B		   *	    pop    bx
 0DD4  5F		   *	    pop    di
 0DD5  5E		   *	    pop    si
 0DD6  5D		   *	    pop    bp
 0DD7  C3		   *	    ret    00000h
 0DD8				strstr	ENDP

				; ------------------------------------------------------------------
				; char *strtok(char *str, const char *delim)
				; ------------------------------------------------------------------
 0DD8				strtok PROC uses si di bx string:WORD, delim:WORD
 0DD8  55		   *	    push   bp
 0DD9  8B EC		   *	    mov    bp, sp
 0DDB  56		   *	    push   si
 0DDC  57		   *	    push   di
 0DDD  53		   *	    push   bx
 0DDE  8B 76 04			    mov si, string						; Point to haystack address
 0DE1  8B 7E 04			    mov di, string						; This function makes me wanta kill myself

				    clearBuff return_buffer
 0DE4  57		     1	    push di
 0DE5  51		     1	    push cx
 0DE6  50		     1	    push ax
 0DE7  FC		     1	    cld
 0DE8  BF 0000 R	     1	    mov di, offset return_buffer
 0DEB  B9 0040		     1	    mov cx, sizeof return_buffer						; Repeat for the length of the buffer
 0DEE  B0 00		     1	    mov al, 0							; Clear with null (0)
 0DF0  F3/ AA		     1	    rep stosb
 0DF2  5F		     1	    pop di
 0DF3  59		     1	    pop cx
 0DF4  58		     1	    pop ax

 0DF5  8A 1D			    mov bl, [di]						; Byte from DI
 0DF7  0A DB			    or bl, bl
 0DF9  74 02			    jz @@s
 0DFB  EB 5B			    jmp @@f

 0DFD				  @@s:
 0DFD  BE 0040 R		    mov si, offset strtok_buffer
 0E00  BF 0000 R		    mov di, offset return_buffer
 0E03  8A 04			    mov al, [si]
 0E05  0A C0			    or al, al
 0E07  75 05			    jnz @@s_fill_return
 0E09  B8 0000			    mov ax, 0
 0E0C  EB 75			    jmp @@done

 0E0E				  @@s_fill_return:
 0E0E  AC			    lodsb							; Get byte from SI into AL
 0E0F  3A 46 06			    cmp al, [bp + 6]
 0E12  74 05			    je @@s_found_delim
 0E14  AA			    stosb							; Store AL into DI
 0E15  0A C0			    or al, al							; End of string?
 0E17  75 F5			    jnz @@s_fill_return

 0E19				  @@s_found_delim:
 0E19  BF 0080 R		    mov di, offset token_buffer

 0E1C				  @@s_fill_token:
 0E1C  AC			    lodsb							; Get byte from SI into AL
 0E1D  AA			    stosb							; Store AL into DI
 0E1E  0A C0			    or al, al							; End of string?
 0E20  75 FA			    jnz @@s_fill_token

				    clearBuff strtok_buffer
 0E22  57		     1	    push di
 0E23  51		     1	    push cx
 0E24  50		     1	    push ax
 0E25  FC		     1	    cld
 0E26  BF 0040 R	     1	    mov di, offset strtok_buffer
 0E29  B9 0040		     1	    mov cx, sizeof strtok_buffer						; Repeat for the length of the buffer
 0E2C  B0 00		     1	    mov al, 0							; Clear with null (0)
 0E2E  F3/ AA		     1	    rep stosb
 0E30  5F		     1	    pop di
 0E31  59		     1	    pop cx
 0E32  58		     1	    pop ax

 0E33  BF 0040 R		    mov di, offset strtok_buffer
 0E36  BE 0080 R		    mov si, offset token_buffer

 0E39				  @@s_fill_strtok:
 0E39  AC			    lodsb							; Get byte from SI into AL
 0E3A  AA			    stosb							; Store AL into DI
 0E3B  0A C0			    or al, al							; End of string?
 0E3D  75 FA			    jnz @@s_fill_strtok

				    clearBuff token_buffer
 0E3F  57		     1	    push di
 0E40  51		     1	    push cx
 0E41  50		     1	    push ax
 0E42  FC		     1	    cld
 0E43  BF 0080 R	     1	    mov di, offset token_buffer
 0E46  B9 0040		     1	    mov cx, sizeof token_buffer						; Repeat for the length of the buffer
 0E49  B0 00		     1	    mov al, 0							; Clear with null (0)
 0E4B  F3/ AA		     1	    rep stosb
 0E4D  5F		     1	    pop di
 0E4E  59		     1	    pop cx
 0E4F  58		     1	    pop ax

 0E50  B8 0000 R		    mov ax, offset return_buffer
				    ret
 0E53  5B		   *	    pop    bx
 0E54  5F		   *	    pop    di
 0E55  5E		   *	    pop    si
 0E56  5D		   *	    pop    bp
 0E57  C3		   *	    ret    00000h

 0E58				  @@f:
				    clearBuff strtok_buffer
 0E58  57		     1	    push di
 0E59  51		     1	    push cx
 0E5A  50		     1	    push ax
 0E5B  FC		     1	    cld
 0E5C  BF 0040 R	     1	    mov di, offset strtok_buffer
 0E5F  B9 0040		     1	    mov cx, sizeof strtok_buffer						; Repeat for the length of the buffer
 0E62  B0 00		     1	    mov al, 0							; Clear with null (0)
 0E64  F3/ AA		     1	    rep stosb
 0E66  5F		     1	    pop di
 0E67  59		     1	    pop cx
 0E68  58		     1	    pop ax
 0E69  BF 0000 R		    mov di, offset return_buffer	; Point to buffer address

 0E6C				  @@f_fill_return:
 0E6C  AC			    lodsb							; Get byte from SI into AL
 0E6D  3A 46 04			    cmp al, [bp+4]
 0E70  74 05			    je @@f_found_delim
 0E72  AA			    stosb							; Store AL into DI
 0E73  0A C0			    or al, al						; End of string?
 0E75  75 F5			    jnz @@f_fill_return

 0E77				  @@f_found_delim:
 0E77  BF 0040 R		    mov di, offset strtok_buffer

 0E7A				  @@f_fill_strtok:
 0E7A  AC			    lodsb							; Get byte from SI into AL
 0E7B  AA			    stosb							; Store AL into DI
 0E7C  0A C0			    or al, al						; End of string?
 0E7E  75 FA			    jnz @@f_fill_strtok
 0E80  B8 0000 R		    mov ax, offset return_buffer

 0E83				  @@done:
				    ret
 0E83  5B		   *	    pop    bx
 0E84  5F		   *	    pop    di
 0E85  5E		   *	    pop    si
 0E86  5D		   *	    pop    bp
 0E87  C3		   *	    ret    00000h
 0E88				strtok ENDP

				; ------------------------------------------------------------------
				; size_t strxfrm(char *dest, const char *src, size_t n)
				; ------------------------------------------------------------------
				; This function transforms the first n chars of src
				; into the locale and puts them into the dest.

 0E88				strxfrm PROC uses di si cx dest:WORD, src:WORD, n:PTR BYTE
 0E88  55		   *	    push   bp
 0E89  8B EC		   *	    mov    bp, sp
 0E8B  57		   *	    push   di
 0E8C  56		   *	    push   si
 0E8D  51		   *	    push   cx
 0E8E  8B 7E 04			    mov di, dest							; Point to str1 address
 0E91  8B 76 06			    mov si, src							; Point to str2 address

 0E94  33 C9			    xor cx, cx

 0E96				  @@loop:								; Get length of SI
 0E96  AC			    lodsb								; Get character from string
 0E97  0A C0			    or al, al								; End of string
 0E99  74 03			    jz @@cont
 0E9B  41			    inc cx
 0E9C  EB F8			    jmp @@loop

 0E9E				  @@cont:
 0E9E  51			    push cx								; Save length of SI
 0E9F  8B 4E 08			    mov cx, n							; Point to n addres
 0EA2  8B 76 06			    mov si, src							; Point to str2 address

 0EA5				  @@append:
 0EA5  8A 04			    mov al, [si]							; Transfer contents of source to dest up to n
 0EA7  88 05			    mov [di], al
 0EA9  46			    inc si
 0EAA  47			    inc di
 0EAB  E2 F8			    loop @@append

 0EAD				  @@done:
 0EAD  59			    pop cx
 0EAE  8B C1			    mov ax, cx
				    ret
 0EB0  59		   *	    pop    cx
 0EB1  5E		   *	    pop    si
 0EB2  5F		   *	    pop    di
 0EB3  5D		   *	    pop    bp
 0EB4  C3		   *	    ret    00000h
 0EB5				strxfrm ENDP
				END
Microsoft (R) Macro Assembler Version 6.15.8803		    09/07/17 22:04:37
source\string.asm					     Symbols 2 - 1




Macros:

                N a m e                 Type

clearBuff  . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_TEXT  . . . . . . . . . . . . .	16 Bit	 0EB5	  Word	  Public  'CODE'	
_DATA  . . . . . . . . . . . . .	16 Bit	 0114	  Word	  Public  'DATA'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

clrscr . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
cprintf  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
cputsxy  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
cputs  . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
cscanf . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
cursoroff  . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
cursoron . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
delay  . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
drawline . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
getche . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
getch  . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
gotoxy . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
highvideo  . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
insline  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
kbhit  . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
lowvideo . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
memchr . . . . . . . . . . . . .	P Near	 0C3C	  _TEXT	Length= 0045 Public C
  string . . . . . . . . . . . .	Word	 bp + 0004
  char . . . . . . . . . . . . .	Byte	 bp + 0006
  n  . . . . . . . . . . . . . .	Word	 bp + 0008
  @@loop . . . . . . . . . . . .	L Near	 0C5A	  _TEXT	
  @@iterate  . . . . . . . . . .	L Near	 0C6E	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 0C78	  _TEXT	
memcmp . . . . . . . . . . . . .	P Near	 0BF7	  _TEXT	Length= 0045 Public C
  str1 . . . . . . . . . . . . .	Word	 bp + 0004
  str2 . . . . . . . . . . . . .	Word	 bp + 0006
  n  . . . . . . . . . . . . . .	Word	 bp + 0008
  @@cmp  . . . . . . . . . . . .	L Near	 0C0B	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 0C1F	  _TEXT	
memcpy . . . . . . . . . . . . .	P Near	 0BD4	  _TEXT	Length= 0023 Public C
  dest . . . . . . . . . . . . .	Word	 bp + 0004
  src  . . . . . . . . . . . . .	Word	 bp + 0006
  n  . . . . . . . . . . . . . .	Word	 bp + 0008
  @@cpy  . . . . . . . . . . . .	L Near	 0BE4	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 0BF1	  _TEXT	
memmove  . . . . . . . . . . . .	P Near	 0BB6	  _TEXT	Length= 001E Public C
  dest . . . . . . . . . . . . .	Word	 bp + 0004
  src  . . . . . . . . . . . . .	Word	 bp + 0006
  n  . . . . . . . . . . . . . .	Word	 bp + 0008
  @@append . . . . . . . . . . .	L Near	 0BC6	  _TEXT	
memset . . . . . . . . . . . . .	P Near	 0B9B	  _TEXT	Length= 001B Public C
  string . . . . . . . . . . . .	Word	 bp + 0004
  char . . . . . . . . . . . . .	Byte	 bp + 0006
  n  . . . . . . . . . . . . . .	Word	 bp + 0008
  @@append . . . . . . . . . . .	L Near	 0BA8	  _TEXT	
newline  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
plotImage  . . . . . . . . . . .	P Near	 09CB	  _TEXT	Length= 002E Public C
putch  . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
setcursortype  . . . . . . . . .	P Near	 0000	  Length= 0000 External C
strcat . . . . . . . . . . . . .	P Near	 0B56	  _TEXT	Length= 0022 Public C
  dest . . . . . . . . . . . . .	Word	 bp + 0004
  src  . . . . . . . . . . . . .	Word	 bp + 0006
  @@inc  . . . . . . . . . . . .	L Near	 0B62	  _TEXT	
  @@append . . . . . . . . . . .	L Near	 0B69	  _TEXT	
strchr . . . . . . . . . . . . .	P Near	 0B1C	  _TEXT	Length= 003A Public C
  string . . . . . . . . . . . .	Word	 bp + 0004
  n  . . . . . . . . . . . . . .	Byte	 bp + 0006
  @@loop . . . . . . . . . . . .	L Near	 0B3C	  _TEXT	
  @@found  . . . . . . . . . . .	L Near	 0B46	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 0B4E	  _TEXT	
strcmp . . . . . . . . . . . . .	P Near	 09F9	  _TEXT	Length= 0042 Public C
  str1 . . . . . . . . . . . . .	Word	 bp + 0004
  str2 . . . . . . . . . . . . .	Word	 bp + 0006
  @@cmp  . . . . . . . . . . . .	L Near	 0A09	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 0A1D	  _TEXT	
strcoll  . . . . . . . . . . . .	P Near	 0A87	  _TEXT	Length= 0046 Public C
  str1 . . . . . . . . . . . . .	Word	 bp + 0004
  str2 . . . . . . . . . . . . .	Word	 bp + 0006
strcpy . . . . . . . . . . . . .	P Near	 0ACD	  _TEXT	Length= 0019 Public C
  dest . . . . . . . . . . . . .	Word	 bp + 0004
  src  . . . . . . . . . . . . .	Word	 bp + 0006
  @@cpy  . . . . . . . . . . . .	L Near	 0ADA	  _TEXT	
strcspn  . . . . . . . . . . . .	P Near	 0C81	  _TEXT	Length= 002F Public C
  str1 . . . . . . . . . . . . .	Word	 bp + 0004
  str2 . . . . . . . . . . . . .	Word	 bp + 0006
  @@cmp  . . . . . . . . . . . .	L Near	 0C90	  _TEXT	
  @@char . . . . . . . . . . . .	L Near	 0C93	  _TEXT	
  @@exit . . . . . . . . . . . .	L Near	 0CA7	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 0CA8	  _TEXT	
strlen . . . . . . . . . . . . .	P Near	 0B04	  _TEXT	Length= 0018 Public C
  string . . . . . . . . . . . .	Word	 bp + 0004
  @@loop . . . . . . . . . . . .	L Near	 0B0E	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 0B16	  _TEXT	
strncat  . . . . . . . . . . . .	P Near	 0B78	  _TEXT	Length= 0023 Public C
  dest . . . . . . . . . . . . .	Word	 bp + 0004
  src  . . . . . . . . . . . . .	Word	 bp + 0006
  n  . . . . . . . . . . . . . .	Word	 bp + 0008
  @@inc  . . . . . . . . . . . .	L Near	 0B87	  _TEXT	
  @@append . . . . . . . . . . .	L Near	 0B8E	  _TEXT	
strncmp  . . . . . . . . . . . .	P Near	 0A3B	  _TEXT	Length= 004C Public C
  str1 . . . . . . . . . . . . .	Word	 bp + 0004
  str2 . . . . . . . . . . . . .	Word	 bp + 0006
  n  . . . . . . . . . . . . . .	Word	 bp + 0008
strncpy  . . . . . . . . . . . .	P Near	 0AE6	  _TEXT	Length= 001E Public C
  dest . . . . . . . . . . . . .	Word	 bp + 0004
  src  . . . . . . . . . . . . .	Word	 bp + 0006
  n  . . . . . . . . . . . . . .	Word	 bp + 0008
  @@cpy  . . . . . . . . . . . .	L Near	 0AF6	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 0AFE	  _TEXT	
strpbrk  . . . . . . . . . . . .	P Near	 0CB0	  _TEXT	Length= 0050 Public C
  str1 . . . . . . . . . . . . .	Word	 bp + 0004
  str2 . . . . . . . . . . . . .	Word	 bp + 0006
  @@cmp  . . . . . . . . . . . .	L Near	 0CCD	  _TEXT	
  @@char . . . . . . . . . . . .	L Near	 0CD0	  _TEXT	
  @@equal  . . . . . . . . . . .	L Near	 0CE3	  _TEXT	
  @@fill . . . . . . . . . . . .	L Near	 0CE7	  _TEXT	
  @@buff . . . . . . . . . . . .	L Near	 0CF3	  _TEXT	
  @@error  . . . . . . . . . . .	L Near	 0CF8	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 0CFB	  _TEXT	
strrchr  . . . . . . . . . . . .	P Near	 0D00	  _TEXT	Length= 0054 Public C
  str1 . . . . . . . . . . . . .	Word	 bp + 0004
  n  . . . . . . . . . . . . . .	Byte	 bp + 0006
  @@cmp  . . . . . . . . . . . .	L Near	 0D20	  _TEXT	
  @@found  . . . . . . . . . . .	L Near	 0D29	  _TEXT	
  @@cont . . . . . . . . . . . .	L Near	 0D2B	  _TEXT	
  @@fill . . . . . . . . . . . .	L Near	 0D33	  _TEXT	
  @@iterate  . . . . . . . . . .	L Near	 0D3D	  _TEXT	
  @@error  . . . . . . . . . . .	L Near	 0D47	  _TEXT	
  @@finished . . . . . . . . . .	L Near	 0D4B	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 0D4E	  _TEXT	
strspn . . . . . . . . . . . . .	P Near	 0D54	  _TEXT	Length= 0026 Public C
  str1 . . . . . . . . . . . . .	Word	 bp + 0004
  str2 . . . . . . . . . . . . .	Word	 bp + 0006
  @@cmp  . . . . . . . . . . . .	L Near	 0D62	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 0D73	  _TEXT	
strstr . . . . . . . . . . . . .	P Near	 0D7A	  _TEXT	Length= 005E Public C
  haystack . . . . . . . . . . .	Word	 bp + 0004
  needle . . . . . . . . . . . .	Word	 bp + 0006
  @@cmp  . . . . . . . . . . . .	L Near	 0D9A	  _TEXT	
  @@cmpstr . . . . . . . . . . .	L Near	 0DA3	  _TEXT	
  @@notequal . . . . . . . . . .	L Near	 0DB3	  _TEXT	
  @@cont . . . . . . . . . . . .	L Near	 0DB4	  _TEXT	
  @@equal  . . . . . . . . . . .	L Near	 0DBC	  _TEXT	
  @@iterate  . . . . . . . . . .	L Near	 0DC5	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 0DCF	  _TEXT	
strtok . . . . . . . . . . . . .	P Near	 0DD8	  _TEXT	Length= 00B0 Public C
  string . . . . . . . . . . . .	Word	 bp + 0004
  delim  . . . . . . . . . . . .	Word	 bp + 0006
  @@s  . . . . . . . . . . . . .	L Near	 0DFD	  _TEXT	
  @@s_fill_return  . . . . . . .	L Near	 0E0E	  _TEXT	
  @@s_found_delim  . . . . . . .	L Near	 0E19	  _TEXT	
  @@s_fill_token . . . . . . . .	L Near	 0E1C	  _TEXT	
  @@s_fill_strtok  . . . . . . .	L Near	 0E39	  _TEXT	
  @@f  . . . . . . . . . . . . .	L Near	 0E58	  _TEXT	
  @@f_fill_return  . . . . . . .	L Near	 0E6C	  _TEXT	
  @@f_found_delim  . . . . . . .	L Near	 0E77	  _TEXT	
  @@f_fill_strtok  . . . . . . .	L Near	 0E7A	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 0E83	  _TEXT	
strxfrm  . . . . . . . . . . . .	P Near	 0E88	  _TEXT	Length= 002D Public C
  dest . . . . . . . . . . . . .	Word	 bp + 0004
  src  . . . . . . . . . . . . .	Word	 bp + 0006
  n  . . . . . . . . . . . . . .	Word	 bp + 0008
  @@loop . . . . . . . . . . . .	L Near	 0E96	  _TEXT	
  @@cont . . . . . . . . . . . .	L Near	 0E9E	  _TEXT	
  @@append . . . . . . . . . . .	L Near	 0EA5	  _TEXT	
  @@done . . . . . . . . . . . .	L Near	 0EAD	  _TEXT	
textbackground . . . . . . . . .	P Near	 0000	  Length= 0000 External C
textcolor  . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
ungetch  . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
wherex . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C
wherey . . . . . . . . . . . . .	P Near	 0000	  Length= 0000 External C


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0001h	 
@Model . . . . . . . . . . . . .	Number	 0001h	 
@code  . . . . . . . . . . . . .	Text   	 DGROUP
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
_CONIO_  . . . . . . . . . . . .	Text   	 1
_STRING_ . . . . . . . . . . . .	Text   	 1
buffered . . . . . . . . . . . .	Byte	 00C1	  _DATA	
derpImage  . . . . . . . . . . .	Byte	 0254	  _TEXT	
derpSize . . . . . . . . . . . .	Number	 00FFh	 
hexstr . . . . . . . . . . . . .	Byte	 0101	  _DATA	
memesImage . . . . . . . . . . .	Byte	 0452	  _TEXT	
memesSize  . . . . . . . . . . .	Number	 02BCh	 
outstr16 . . . . . . . . . . . .	Byte	 0111	  _DATA	
penImage . . . . . . . . . . . .	Byte	 0000	  _TEXT	
penSize  . . . . . . . . . . . .	Number	 012Ah	 
return_buffer  . . . . . . . . .	Byte	 0000	  _DATA	
strtok_buffer  . . . . . . . . .	Byte	 0040	  _DATA	
token_buffer . . . . . . . . . .	Byte	 0080	  _DATA	
txtbg  . . . . . . . . . . . . .	Byte	 00C0	  _DATA	

	   0 Warnings
	   0 Errors
